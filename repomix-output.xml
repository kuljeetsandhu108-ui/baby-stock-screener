This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.dockerignore
.gitignore
backend/app/__init__.py
backend/app/main.py
backend/app/routers/__init__.py
backend/app/routers/charts.py
backend/app/routers/indices.py
backend/app/routers/stocks.py
backend/app/services/__init__.py
backend/app/services/fmp_service.py
backend/app/services/fundamental_service.py
backend/app/services/gemini_service.py
backend/app/services/indian_service.py
backend/app/services/news_service.py
backend/app/services/sentiment_service.py
backend/app/services/technical_service.py
backend/app/services/yahoo_service.py
backend/requirements.txt
Dockerfile
frontend/package.json
frontend/public/index.html
frontend/src/api/stockApi.js
frontend/src/App.js
frontend/src/components/Chart/TradingViewChart.js
frontend/src/components/common/Card.js
frontend/src/components/common/Loader.js
frontend/src/components/common/Tabs/NestedTabs.js
frontend/src/components/common/Tabs/Tabs.js
frontend/src/components/Financials/AboutCompany.js
frontend/src/components/Financials/BalanceSheet.js
frontend/src/components/Financials/Financials.js
frontend/src/components/Financials/FinancialStatements.js
frontend/src/components/Financials/KeyStats.js
frontend/src/components/Financials/RevenueChart.js
frontend/src/components/Financials/StatementTable.js
frontend/src/components/Forecasts/AnalystRating.js
frontend/src/components/Forecasts/Forecasts.js
frontend/src/components/Forecasts/PriceTarget.js
frontend/src/components/Fundamentals/BenjaminGrahamScan.js
frontend/src/components/Fundamentals/DarvasScan.js
frontend/src/components/Fundamentals/FundamentalConclusion.js
frontend/src/components/Fundamentals/Fundamentals.js
frontend/src/components/Header/StockHeader.js
frontend/src/components/HomePage/ChartUploader.js
frontend/src/components/Indices/IndicesBanner.js
frontend/src/components/News/NewsList.js
frontend/src/components/Peers/PeersComparison.js
frontend/src/components/Sentiment/OverallSentiment.js
frontend/src/components/Shareholding/DonutChart.js
frontend/src/components/Shareholding/OwnershipTrend.js
frontend/src/components/Shareholding/Shareholding.js
frontend/src/components/Shareholding/TrendChart.js
frontend/src/components/StockDetailPage/ChartAnalysis.js
frontend/src/components/SWOT/SwotAnalysis.js
frontend/src/components/Technicals/MovingAverages.js
frontend/src/components/Technicals/PivotLevels.js
frontend/src/components/Technicals/RatingDial.js
frontend/src/components/Technicals/TechnicalIndicatorsTable.js
frontend/src/components/Technicals/Technicals.js
frontend/src/index.js
frontend/src/pages/HomePage.js
frontend/src/pages/IndexDetailPage.js
frontend/src/pages/StockDetailPage.js
frontend/src/styles/GlobalStyles.js
nixpacks.toml
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/app/services/indian_service.py">
import os
import requests
from dotenv import load_dotenv

load_dotenv()

# 1. Get the key
INDIAN_API_KEY = os.getenv("INDIAN_API_KEY")

# 2. Set your specific provider URL here (Example: A common RapidAPI endpoint)
# You will replace this URL with the specific one you subscribe to.
BASE_URL = "https://latest-stock-price.p.rapidapi.com" 

def get_indian_shareholding(symbol: str):
    """
    Fetches precise shareholding pattern for Indian stocks from a dedicated API.
    """
    if not INDIAN_API_KEY:
        return None

    # Clean the symbol: Remove .NS or .BO for many Indian APIs
    clean_symbol = symbol.replace('.NS', '').replace('.BO', '')

    headers = {
        "X-RapidAPI-Key": INDIAN_API_KEY,
        "X-RapidAPI-Host": "latest-stock-price.p.rapidapi.com" # Update this host to match your provider
    }

    try:
        # Example endpoint structure - Update based on your specific API documentation
        url = f"{BASE_URL}/shareholding-pattern?symbol={clean_symbol}"
        
        response = requests.get(url, headers=headers)
        response.raise_for_status()
        data = response.json()

        # --- NORMALIZE DATA ---
        # Convert the specific API's response to our standard format
        # (This logic depends on the exact response format of the API you choose)
        
        return {
            "promoter": data.get('promoter', 0),
            "fii": data.get('fii', 0),
            "dii": data.get('dii', 0),
            "public": data.get('public', 0)
        }

    except Exception as e:
        print(f"Error fetching Indian shareholding for {symbol}: {e}")
        return None
</file>

<file path=".dockerignore">
# Git
.git
.gitignore

# Python
backend/venv
backend/__pycache__

# Node
frontend/node_modules
frontend/build

# Docker
Dockerfile
</file>

<file path=".gitignore">
# Python
/backend/venv/
/backend/__pycache__/
/backend/.env

# Node
/frontend/node_modules/
/frontend/build/
/frontend/.env

# IDE
.vscode/
</file>

<file path="backend/app/__init__.py">

</file>

<file path="backend/app/routers/__init__.py">

</file>

<file path="backend/app/routers/indices.py">
import asyncio
from fastapi import APIRouter, HTTPException
import yfinance as yf
import pandas as pd
from ..services import yahoo_service, fmp_service

router = APIRouter()

# --- THE NEW, SMARTER MASTER LIST ---
# We've added 'currency' and 'tradingview_symbol' to each index.
INDEX_MAP = {
    "Nifty 50":           {"symbol": "^NSEI",     "proxy_etf": "INDA", "currency": "INR", "tradingview_symbol": "NSE:NIFTY"},
    "Bank Nifty":         {"symbol": "^NSEBANK",  "proxy_etf": "INDA", "currency": "INR", "tradingview_symbol": "NSE:BANKNIFTY"},
    "Sensex":             {"symbol": "^BSESN",    "proxy_etf": "INDA", "currency": "INR", "tradingview_symbol": "BSE:SENSEX"},
    "Dow Jones":          {"symbol": "^DJI",      "proxy_etf": "DIA",  "currency": "USD", "tradingview_symbol": "DJ:DJI"},
    "Nasdaq":             {"symbol": "^IXIC",     "proxy_etf": "QQQ",  "currency": "USD", "tradingview_symbol": "NASDAQ:IXIC"},
    "Nikkei 225":         {"symbol": "^N225",     "proxy_etf": "EWJ",  "currency": "JPY", "tradingview_symbol": "NIKKEI:NI225"},
    "Gift Nifty":         {"symbol": "NIFTY=F",   "proxy_etf": "INDA", "currency": "USD", "tradingview_symbol": "SGX:IN1!"}, # Futures are often USD denominated
    "India VIX":          {"symbol": "^INDIAVIX", "proxy_etf": None, "currency": "INR", "tradingview_symbol": "NSE:INDIAVIX"},
}

def fetch_summary_data_simple_and_robust():
    # ... (this function does not need to change)
    summary_list = []
    symbols_string = " ".join([info["symbol"] for info in INDEX_MAP.values()])
    tickers = yf.Tickers(symbols_string)
    for name, info in INDEX_MAP.items():
        symbol = info["symbol"]
        try:
            ticker_info = tickers.tickers[symbol].info
            current_price = ticker_info.get('regularMarketPrice')
            previous_close = ticker_info.get('previousClose')
            if current_price is None or previous_close is None: continue
            change = current_price - previous_close
            percent_change = (change / previous_close) * 100
            summary_list.append({
                "name": name, "symbol": symbol, "price": current_price,
                "change": change, "percent_change": percent_change,
            })
        except Exception as e:
            print(f"Could not process summary for {name} ({symbol}): {e}")
            continue
    return summary_list

@router.get("/summary")
async def get_indices_summary():
    # ... (this endpoint does not change)
    summary_data = await asyncio.to_thread(fetch_summary_data_simple_and_robust)
    return summary_data

@router.get("/{index_symbol:path}/live-price")
async def get_index_live_price(index_symbol: str):
    # ... (this endpoint does not change)
    try:
        ticker = yf.Ticker(index_symbol)
        info = ticker.info
        current_price = info.get('regularMarketPrice')
        previous_close = info.get('previousClose')
        if current_price is None or previous_close is None: raise HTTPException(status_code=404, detail="Live price not available.")
        change = current_price - previous_close
        percent_change = (change / previous_close) * 100
        return {"price": current_price, "change": change, "changesPercentage": percent_change}
    except Exception as e:
        raise HTTPException(status_code=500, detail="Failed to fetch live price.")

# --- THE UPDATED DETAILS ENDPOINT ---
@router.get("/{index_symbol:path}/details")
async def get_index_details(index_symbol: str):
    index_name, proxy_etf, currency, tv_symbol = "Index", None, "USD", index_symbol
    for name, data in INDEX_MAP.items():
        if data["symbol"] == index_symbol:
            index_name, proxy_etf, currency, tv_symbol = name, data["proxy_etf"], data["currency"], data["tradingview_symbol"]
            break

    hist_df = await asyncio.to_thread(yahoo_service.get_historical_data, index_symbol, "5y")
    technicals = await asyncio.to_thread(yahoo_service.calculate_technical_indicators, hist_df.copy() if hist_df is not None else None)
    
    if proxy_etf:
        proxy_tasks = {
            "profile": asyncio.to_thread(fmp_service.get_company_profile, proxy_etf),
            "quote": asyncio.to_thread(fmp_service.get_quote, proxy_etf),
            "analyst_ratings": asyncio.to_thread(yahoo_service.get_analyst_recommendations, proxy_etf),
        }
        proxy_results = await asyncio.gather(*proxy_tasks.values(), return_exceptions=True)
        proxy_data = dict(zip(proxy_tasks.keys(), proxy_results))
        for key, value in proxy_data.items():
            if isinstance(value, Exception): proxy_data[key] = {} if isinstance(proxy_data[key], dict) else []
        proxy_data['profile'] = proxy_data['profile'][0] if isinstance(proxy_data['profile'], list) and proxy_data['profile'] else {}
        proxy_data['quote'] = proxy_data['quote'][0] if isinstance(proxy_data['quote'], list) and proxy_data['quote'] else {}
    else:
        proxy_data = {"profile": {}, "quote": {}, "analyst_ratings": []}

    combined_data = {
        "profile": {
            "companyName": index_name,
            "symbol": index_symbol,
            "image": proxy_data.get("profile", {}).get("image"),
            # --- PASSING THE NEW INTELLIGENCE TO THE FRONTEND ---
            "currency": currency,
            "tradingview_symbol": tv_symbol,
        },
        "quote": proxy_data.get("quote", {}),
        "technical_indicators": technicals,
        "analyst_ratings": proxy_data.get("analyst_ratings", []),
    }
    
    return combined_data
</file>

<file path="backend/app/services/__init__.py">

</file>

<file path="backend/app/services/news_service.py">
import os
import requests
from dotenv import load_dotenv

# Load environment variables from the .env file in the `backend` directory
load_dotenv()

NEWS_API_KEY = os.getenv("NEWS_API_KEY")
BASE_URL = "https://newsapi.org/v2/everything"

def get_company_news(query: str, page_size: int = 20):
    """
    Fetches recent news articles related to a specific company or query
    from the News API. It sorts by the most recently published.
    """
    if not NEWS_API_KEY:
        print("Error: NEWS_API_KEY not found in .env file.")
        return {"error": "News API key not configured."}
    
    # We add quotes around the query for more exact matches
    # e.g., searching for "Apple Inc" instead of just Apple
    params = {
        "q": f'"{query}"',
        "apiKey": NEWS_API_KEY,
        "language": "en",
        "sortBy": "publishedAt",
        "pageSize": page_size
    }
    
    try:
        response = requests.get(BASE_URL, params=params)
        response.raise_for_status()  # Raises an HTTPError for bad responses
        
        # We extract only the 'articles' list from the response
        return response.json().get("articles", [])
        
    except requests.exceptions.RequestException as e:
        print(f"Error fetching company news for '{query}': {e}")
        return []
</file>

<file path="backend/app/services/sentiment_service.py">
def calculate_overall_sentiment(piotroski_score: int, pe_ratio, analyst_ratings: list, rsi):
    """
    Calculates a hybrid sentiment score from 0 to 100 based on four pillars:
    Fundamental Health, Valuation, Analyst Opinion, and Technical Momentum.
    """
    scores = {}
    
    # Pillar 1: Fundamental Health (Piotroski Score) - Weight: 30%
    if piotroski_score is not None:
        # Scale 0-9 score to 0-100
        scores['fundamental'] = (piotroski_score / 9) * 100
    
    # Pillar 2: Valuation (P/E Ratio) - Weight: 20%
    if pe_ratio is not None and pe_ratio > 0:
        if pe_ratio < 15: scores['valuation'] = 100  # Very Undervalued
        elif pe_ratio < 25: scores['valuation'] = 75   # Fairly Valued
        elif pe_ratio < 40: scores['valuation'] = 40   # Expensive
        else: scores['valuation'] = 10               # Very Expensive
        
    # Pillar 3: Analyst Opinion - Weight: 30%
    if analyst_ratings and len(analyst_ratings) > 0:
        latest_rating = analyst_ratings[0]
        strong_buy = latest_rating.get('ratingStrongBuy', 0)
        buy = latest_rating.get('ratingBuy', 0)
        hold = latest_rating.get('ratingHold', 0)
        sell = latest_rating.get('ratingSell', 0)
        strong_sell = latest_rating.get('ratingStrongSell', 0)
        
        total_analysts = strong_buy + buy + hold + sell + strong_sell
        if total_analysts > 0:
            # Weighted score: Strong Buy=5, Buy=4, Hold=3, Sell=2, Strong Sell=1
            score = (strong_buy*5 + buy*4 + hold*3 + sell*2 + strong_sell*1) / total_analysts
            # Scale 1-5 score to 0-100
            scores['analyst'] = ((score - 1) / 4) * 100
            
    # Pillar 4: Technical Momentum (RSI) - Weight: 20%
    if rsi is not None:
        # We treat RSI as a contrarian indicator for sentiment.
        # Very oversold (<30) is bullish, very overbought (>70) is bearish.
        if rsi < 30: scores['technical'] = 100 # Oversold (Bullish sentiment)
        elif rsi > 70: scores['technical'] = 0  # Overbought (Bearish sentiment)
        else:
            # Linear scale for the neutral zone
            scores['technical'] = 100 - ((rsi - 30) / (70 - 30)) * 100
            
    # --- Final Calculation ---
    if not scores:
        return {"score": 50, "verdict": "Neutral"} # Default if no data is available

    # Weighted average of all available scores
    total_score = 0
    total_weight = 0
    weights = {'fundamental': 0.3, 'valuation': 0.2, 'analyst': 0.3, 'technical': 0.2}
    
    for pillar, score in scores.items():
        total_score += score * weights[pillar]
        total_weight += weights[pillar]
        
    final_score = total_score / total_weight if total_weight > 0 else 50

    # Determine a human-readable verdict
    verdict = "Neutral"
    if final_score > 75: verdict = "Very Bullish"
    elif final_score > 60: verdict = "Bullish"
    elif final_score < 25: verdict = "Very Bearish"
    elif final_score < 40: verdict = "Bearish"

    return {"score": final_score, "verdict": verdict}
</file>

<file path="frontend/public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Stellar Stock Screener - AI-Powered Financial Analysis"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    
    <!-- This is where the TradingView library will be loaded from -->
    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>

    <title>Stellar Stock Screener</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    
    <!-- THIS IS THE CRITICAL LINE -->
    <div id="root"></div>
    
  </body>
</html>
</file>

<file path="frontend/src/api/stockApi.js">

</file>

<file path="frontend/src/components/Chart/TradingViewChart.js">
import React, { useEffect, useRef, memo } from 'react';
import Card from '../common/Card';

const TradingViewChart = ({ symbol }) => {
  const container = useRef();

  useEffect(() => {
    // Ensure the TradingView script is loaded and the container ref is set
    if (window.TradingView && container.current) {
      // Clear the container before creating a new widget
      // This is crucial for preventing duplicate charts when the component re-renders
      container.current.innerHTML = '';

      // Create a new TradingView widget instance
      new window.TradingView.widget({
        autosize: true, // This makes the chart fill its container
        symbol: symbol,
        interval: "D", // Daily interval
        timezone: "Etc/UTC",
        theme: "dark", // Dark theme to match our app
        style: "1",
        locale: "en",
        enable_publishing: false,
        allow_symbol_change: true,
        withdateranges: true,
        hide_side_toolbar: false,
        studies: [
          "Volume@tv-basicstudies" // Add volume as a default study
        ],
        container_id: container.current.id,
      });
    }
  }, [symbol]); // Re-run the effect if the stock symbol changes

  return (
    <Card title="Advanced Chart">
      <div 
        ref={container} 
        id={`tradingview_${symbol}`} 
        style={{ height: "600px", width: "100%" }} 
      />
    </Card>
  );
};

// Use React.memo to prevent unnecessary re-renders of the chart
// The chart will only re-render if its 'symbol' prop changes.
export default memo(TradingViewChart);
</file>

<file path="frontend/src/components/common/Loader.js">

</file>

<file path="frontend/src/components/Financials/AboutCompany.js">
import React from 'react';
import styled from 'styled-components';

// --- Styled Components ---

const AboutContainer = styled.div`
  /* Styling for the container if needed in the future */
`;

const SectionTitle = styled.h3`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 1rem;
  color: var(--color-text-primary);
`;

const Description = styled.p`
  font-size: 1rem;
  color: var(--color-text-secondary);
  line-height: 1.7; /* Generous line spacing for readability */
`;


// --- The React Component ---

const AboutCompany = ({ profile }) => {
  // Defensive check: If there is no profile or description, render nothing.
  if (!profile || !profile.description) {
    return null;
  }

  return (
    <AboutContainer>
      <SectionTitle>About {profile.companyName}</SectionTitle>
      <Description>
        {profile.description}
      </Description>
    </AboutContainer>
  );
};

export default AboutCompany;
</file>

<file path="frontend/src/components/Financials/BalanceSheet.js">
import React from 'react';
import styled from 'styled-components';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  Legend,
  ResponsiveContainer,
  CartesianGrid
} from 'recharts';

// --- Styled Components ---

const SectionContainer = styled.div`
  margin-top: 3rem;
  padding-top: 2rem;
  border-top: 1px solid var(--color-border);
`;

const SectionTitle = styled.h3`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 1.5rem;
  color: var(--color-text-primary);
`;

const ChartGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 3rem;
  height: 450px; /* Give a consistent height to the chart area */

  @media (max-width: 992px) {
    grid-template-columns: 1fr;
    height: auto;
    gap: 4rem;
  }
`;

const CustomTooltipContainer = styled.div`
  background-color: #2a3441;
  border: 1px solid var(--color-border);
  padding: 1rem;
  border-radius: 8px;
  color: var(--color-text-primary);
`;

const formatNumber = (num) => {
    if (num === null || num === undefined) return 'N/A';
    if (Math.abs(num) >= 1e9) return `${(num / 1e9).toFixed(2)}B`;
    if (Math.abs(num) >= 1e6) return `${(num / 1e6).toFixed(2)}M`;
    return num.toLocaleString();
};


// --- The React Component ---

const BalanceSheet = ({ balanceSheetData }) => {
  if (!balanceSheetData || !Array.isArray(balanceSheetData) || balanceSheetData.length === 0) {
    return (
      <SectionContainer>
        <SectionTitle>Balance Sheet</SectionTitle>
        <p>Balance sheet data is not available for this stock.</p>
      </SectionContainer>
    );
  }

  // Process the data for our stacked bar charts, reversing for chronological order
  const chartData = balanceSheetData.slice(0, 5).reverse().map(item => ({
    year: item.calendarYear,
    // Assets
    currentAssets: item.totalCurrentAssets,
    longTermAssets: item.totalNonCurrentAssets,
    // Liabilities & Equity
    currentLiabilities: item.totalCurrentLiabilities,
    longTermDebt: item.longTermDebt,
    equity: item.totalStockholdersEquity,
  }));
  
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      return (
        <CustomTooltipContainer>
          <p style={{ fontWeight: 'bold' }}>Year: {label}</p>
          {payload.map(p => (
            <p key={p.dataKey} style={{ color: p.color }}>
              {`${p.name}: ${formatNumber(p.value)}`}
            </p>
          ))}
        </CustomTooltipContainer>
      );
    }
    return null;
  };

  return (
    <SectionContainer>
      <SectionTitle>Balance Sheet Composition (5-Year Trend)</SectionTitle>
      <ChartGrid>
        {/* --- Chart 1: Assets --- */}
        <div>
            <h4 style={{textAlign: 'center', marginBottom: '1rem', color: 'var(--color-text-secondary)'}}>Assets</h4>
            <ResponsiveContainer width="100%" height="100%">
                <BarChart data={chartData} layout="vertical" margin={{ top: 5, right: 20, left: 10, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" stroke="var(--color-border)" />
                    <XAxis type="number" stroke="var(--color-text-secondary)" tickFormatter={formatNumber} />
                    <YAxis type="category" dataKey="year" stroke="var(--color-text-secondary)" />
                    <Tooltip content={<CustomTooltip />} cursor={{ fill: 'rgba(136, 132, 216, 0.1)' }} />
                    <Legend />
                    <Bar dataKey="currentAssets" name="Current Assets" stackId="a" fill="#8884d8" />
                    <Bar dataKey="longTermAssets" name="Long-Term Assets" stackId="a" fill="#82ca9d" />
                </BarChart>
            </ResponsiveContainer>
        </div>

        {/* --- Chart 2: Liabilities & Equity --- */}
        <div>
            <h4 style={{textAlign: 'center', marginBottom: '1rem', color: 'var(--color-text-secondary)'}}>Liabilities & Equity</h4>
            <ResponsiveContainer width="100%" height="100%">
                <BarChart data={chartData} layout="vertical" margin={{ top: 5, right: 20, left: 10, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" stroke="var(--color-border)" />
                    <XAxis type="number" stroke="var(--color-text-secondary)" tickFormatter={formatNumber} />
                    <YAxis type="category" dataKey="year" stroke="var(--color-text-secondary)" />
                    <Tooltip content={<CustomTooltip />} cursor={{ fill: 'rgba(136, 132, 216, 0.1)' }} />
                    <Legend />
                    <Bar dataKey="currentLiabilities" name="Current Liabilities" stackId="b" fill="#FFCB77" />
                    <Bar dataKey="longTermDebt" name="Long-Term Debt" stackId="b" fill="#FE6D73" />
                    <Bar dataKey="equity" name="Equity" stackId="b" fill="#17C3B2" />
                </BarChart>
            </ResponsiveContainer>
        </div>
      </ChartGrid>
    </SectionContainer>
  );
};

export default BalanceSheet;
</file>

<file path="frontend/src/components/Financials/FinancialStatements.js">
import React, { useState } from 'react';
import styled from 'styled-components';
import StatementTable from './StatementTable'; // We will create this next

// --- Styled Components ---

const SectionContainer = styled.div`
  margin-top: 3rem;
  padding-top: 2rem;
  border-top: 1px solid var(--color-border);
`;

const SectionTitle = styled.h3`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 1.5rem;
  color: var(--color-text-primary);
`;

const ToggleContainer = styled.div`
  display: flex;
  justify-content: flex-end;
  margin-bottom: 1.5rem;
`;

const ToggleButton = styled.button`
  padding: 0.5rem 1rem;
  border: 1px solid var(--color-border);
  background-color: ${({ active }) => (active ? 'var(--color-primary)' : 'var(--color-secondary)')};
  color: ${({ active }) => (active ? 'var(--color-background)' : 'var(--color-text-primary)')};
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;

  &:first-child {
    border-radius: 6px 0 0 6px;
  }
  &:last-child {
    border-radius: 0 6px 6px 0;
  }
  &:hover {
    background-color: var(--color-primary);
    color: var(--color-background);
  }
`;

const StatementsGrid = styled.div`
  display: flex;
  flex-direction: column;
  gap: 3rem;
`;

// --- The Main React Component ---

const FinancialStatements = ({
  currency,
  annualIncome, annualBalance, annualCashFlow,
  quarterlyIncome, quarterlyBalance, quarterlyCashFlow
}) => {
  const [period, setPeriod] = useState('annual'); // Default to 'annual'

  const isAnnual = period === 'annual';

  return (
    <SectionContainer>
      <SectionTitle>Financial Statements</SectionTitle>
      
      <ToggleContainer>
        <ToggleButton active={isAnnual} onClick={() => setPeriod('annual')}>
          Annual
        </ToggleButton>
        <ToggleButton active={!isAnnual} onClick={() => setPeriod('quarterly')}>
          Quarterly
        </ToggleButton>
      </ToggleContainer>

      <StatementsGrid>
        {/* We pass the correctly selected data and currency to our table component */}
        <StatementTable
          title="Income Statement"
          data={isAnnual ? annualIncome : quarterlyIncome}
          currency={currency}
        />
        <StatementTable
          title="Balance Sheet"
          data={isAnnual ? annualBalance : quarterlyBalance}
          currency={currency}
        />
        <StatementTable
          title="Cash Flow Statement"
          data={isAnnual ? annualCashFlow : quarterlyCashFlow}
          currency={currency}
        />
      </StatementsGrid>
    </SectionContainer>
  );
};

export default FinancialStatements;
</file>

<file path="frontend/src/components/Financials/KeyStats.js">
import React from 'react';
import styled from 'styled-components';

// --- Styled Components ---

const StatsContainer = styled.div`
  padding-bottom: 2rem;
  margin-bottom: 2rem;
  border-bottom: 1px solid var(--color-border);
`;

const SectionTitle = styled.h3`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 1.5rem;
  color: var(--color-text-primary);
`;

const StatsGrid = styled.div`
  display: grid;
  /* Create 4 equal columns on larger screens */
  grid-template-columns: repeat(4, 1fr);
  gap: 1.5rem 1rem; /* Vertical and horizontal gap */

  /* On smaller screens, reduce to 2 columns */
  @media (max-width: 992px) {
    grid-template-columns: repeat(2, 1fr);
  }
`;

const StatItem = styled.div`
  display: flex;
  flex-direction: column;
`;

const StatLabel = styled.span`
  font-size: 0.9rem;
  color: var(--color-text-secondary);
  margin-bottom: 0.25rem;
`;

const StatValue = styled.span`
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--color-text-primary);
`;

// --- Helper Functions to Format Data ---

const formatMarketCap = (num) => {
  if (num === null || num === undefined) return '--';
  if (num >= 1e12) return `$${(num / 1e12).toFixed(2)} T`;
  if (num >= 1e9) return `$${(num / 1e9).toFixed(2)} B`;
  if (num >= 1e6) return `$${(num / 1e6).toFixed(2)} M`;
  return `$${num}`;
};

const formatNumber = (num) => {
  if (num === null || num === undefined) return '--';
  return num.toFixed(2);
};

const formatDate = (dateStr) => {
    if (!dateStr) return '--';
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
};


// --- The Main React Component ---

const KeyStats = ({ stats }) => {
  if (!stats) return null;

  return (
    <StatsContainer>
      {/* --- Upcoming Earnings Section --- */}
      <SectionTitle>Upcoming Earnings</SectionTitle>
      <StatsGrid>
        <StatItem>
          <StatLabel>Next Report Date</StatLabel>
          <StatValue>{formatDate(stats.nextReportDate)}</StatValue>
        </StatItem>
        <StatItem>
          <StatLabel>EPS Estimate</StatLabel>
          <StatValue>{formatNumber(stats.epsEstimate)}</StatValue>
        </StatItem>
        <StatItem>
          <StatLabel>Revenue Estimate</StatLabel>
          <StatValue>{formatMarketCap(stats.revenueEstimate)}</StatValue>
        </StatItem>
      </StatsGrid>

      {/* --- Key Stats Section --- */}
      <SectionTitle style={{ marginTop: '2rem' }}>Key Stats</SectionTitle>
      <StatsGrid>
        <StatItem>
          <StatLabel>Market Capitalization</StatLabel>
          <StatValue>{formatMarketCap(stats.marketCap)}</StatValue>
        </StatItem>
        <StatItem>
          <StatLabel>Dividend Yield (TTM)</StatLabel>
          <StatValue>{stats.dividendYield ? `${(stats.dividendYield * 100).toFixed(2)}%` : '--'}</StatValue>
        </StatItem>
        <StatItem>
          <StatLabel>Price to Earnings (TTM)</StatLabel>
          <StatValue>{formatNumber(stats.peRatio)}</StatValue>
        </StatItem>
        <StatItem>
          <StatLabel>Basic EPS (TTM)</StatLabel>
          <StatValue>{formatNumber(stats.basicEPS)}</StatValue>
        </StatItem>
        <StatItem>
          <StatLabel>Net Income / Share</StatLabel>
          <StatValue>{formatNumber(stats.netIncome)}</StatValue>
        </StatItem>
        <StatItem>
          <StatLabel>Revenue / Share</StatLabel>
          <StatValue>{formatNumber(stats.revenue)}</StatValue>
        </StatItem>
        <StatItem>
          <StatLabel>Shares Float</StatLabel>
          <StatValue>{formatMarketCap(stats.sharesFloat)}</StatValue>
        </StatItem>
        <StatItem>
          <StatLabel>Beta (1Y)</StatLabel>
          <StatValue>{formatNumber(stats.beta)}</StatValue>
        </StatItem>
      </StatsGrid>
    </StatsContainer>
  );
};

export default KeyStats;
</file>

<file path="frontend/src/components/Financials/RevenueChart.js">
import React from 'react';
import styled from 'styled-components';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  Legend,
  ResponsiveContainer,
  CartesianGrid
} from 'recharts';

// --- Styled Components ---

const ChartContainer = styled.div`
  width: 100%;
  height: 400px; /* Give the chart a fixed height */
`;

// Custom Tooltip for a better look and feel
const CustomTooltipContainer = styled.div`
  background-color: #2a3441;
  border: 1px solid var(--color-border);
  padding: 1rem;
  border-radius: 8px;
  color: var(--color-text-primary);
`;

const TooltipLabel = styled.p`
  margin-bottom: 0.5rem;
  font-weight: bold;
`;

// --- Helper Functions ---

// Formats large numbers into Billions (B) or Millions (M) for the Y-axis
const formatYAxis = (tick) => {
  if (Math.abs(tick) >= 1e9) {
    return `${(tick / 1e9).toFixed(1)}B`;
  }
  if (Math.abs(tick) >= 1e6) {
    return `${(tick / 1e6).toFixed(1)}M`;
  }
  return tick;
};

// Formats large numbers with commas and adds a currency symbol
const formatCurrency = (value) => {
    return `$${new Intl.NumberFormat('en-US').format(value)}`;
};


// --- React Component ---

const RevenueChart = ({ data }) => {
  // The API sends data from newest to oldest, so we reverse it for the chart
  // and process it into a more usable format.
  const chartData = data.slice().reverse().map(item => ({
    year: new Date(item.date).getFullYear(),
    Revenue: item.revenue,
    'Net Profit': item.netIncome,
  }));

  // Custom Tooltip Component
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      return (
        <CustomTooltipContainer>
          <TooltipLabel>{`Year: ${label}`}</TooltipLabel>
          <p style={{ color: '#8884d8' }}>{`Revenue: ${formatCurrency(payload[0].value)}`}</p>
          <p style={{ color: '#82ca9d' }}>{`Net Profit: ${formatCurrency(payload[1].value)}`}</p>
        </CustomTooltipContainer>
      );
    }
    return null;
  };

  return (
    <ChartContainer>
      {/* ResponsiveContainer makes the chart adapt to its parent's size */}
      <ResponsiveContainer width="100%" height="100%">
        <BarChart
          data={chartData}
          margin={{ top: 5, right: 20, left: 30, bottom: 5 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke={ "var(--color-border)" } />
          <XAxis 
            dataKey="year" 
            stroke={ "var(--color-text-secondary)" }
            tick={{ fill: 'var(--color-text-secondary)', fontSize: 12 }} 
          />
          <YAxis 
            stroke={ "var(--color-text-secondary)" }
            tickFormatter={formatYAxis}
            tick={{ fill: 'var(--color-text-secondary)', fontSize: 12 }}
          />
          <Tooltip content={<CustomTooltip />} cursor={{ fill: 'rgba(136, 132, 216, 0.1)' }}/>
          <Legend wrapperStyle={{ fontSize: '14px', paddingTop: '20px' }} />
          <Bar dataKey="Revenue" fill="#8884d8" />
          <Bar dataKey="Net Profit" fill="#82ca9d" />
        </BarChart>
      </ResponsiveContainer>
    </ChartContainer>
  );
};

export default RevenueChart;
</file>

<file path="frontend/src/components/Financials/StatementTable.js">
import React from 'react';
import styled from 'styled-components';

// --- Styled Components ---

const TableWrapper = styled.div`
  width: 100%;
  overflow-x: auto; /* The key to making the table horizontally scrollable */
`;

const StyledTable = styled.table`
  width: 100%;
  min-width: 800px; /* Ensures there's enough space for columns before scrolling */
  border-collapse: collapse;
  text-align: right;
`;

const TableHeader = styled.th`
  padding: 0.75rem 1rem;
  color: var(--color-text-secondary);
  font-weight: 500;
  font-size: 0.9rem;
  border-bottom: 1px solid var(--color-border);
  white-space: nowrap;

  &:first-child {
    text-align: left;
    position: sticky; /* Makes the first column "stick" to the left on scroll */
    left: 0;
    background-color: var(--color-secondary);
    z-index: 1;
  }
`;

const TableRow = styled.tr`
  &:nth-child(even) {
    background-color: rgba(0, 0, 0, 0.2);
  }
`;

const TableCell = styled.td`
  padding: 0.75rem 1rem;
  font-size: 0.95rem;
  font-family: 'Roboto Mono', monospace;
  white-space: nowrap;

  &:first-child {
    font-weight: 600;
    color: var(--color-text-primary);
    text-align: left;
    font-family: 'Inter', sans-serif;
    position: sticky;
    left: 0;
    background-color: var(--color-secondary);
    z-index: 1;
  }
`;

const Subtitle = styled.h4`
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 1rem;
    color: var(--color-text-primary);
`;

// --- Helper Functions ---

const getCurrencySymbol = (currencyCode) => {
    switch (currencyCode) {
        case 'INR': return '₹';
        case 'USD': return '$';
        case 'JPY': return '¥';
        default: return ''; // No symbol if currency is unknown
    }
};

const formatNumber = (num, currencySymbol) => {
    if (num === null || num === undefined || isNaN(num)) return 'N/A';
    // Format large numbers into Millions for readability, prepended with currency
    const value = Math.abs(num);
    const sign = num < 0 ? '-' : '';
    if (value >= 1e6) {
        return `${sign}${currencySymbol}${(value / 1e6).toFixed(2)}M`;
    }
    // For smaller numbers, just add commas
    return `${sign}${currencySymbol}${num.toLocaleString()}`;
};

// --- The Reusable React Component ---

const StatementTable = ({ title, data, currency }) => {
  if (!data || !Array.isArray(data) || data.length === 0) {
    return null; // Don't render if there's no data
  }

  // --- Intelligent Data Key Discovery ---
  // This is the "brain". It finds all the numerical data points available
  // in the first record, excluding known non-financial keys.
  const headers = data.map(item => item.calendarYear || item.date.substring(0, 4));
  const ignoredKeys = new Set(['date', 'symbol', 'reportedCurrency', 'cik', 'fillingDate', 'acceptedDate', 'calendarYear', 'period', 'link', 'finalLink']);
  const dataKeys = Object.keys(data[0]).filter(key => 
      !ignoredKeys.has(key) && typeof data[0][key] === 'number'
  );

  const currencySymbol = getCurrencySymbol(currency);

  return (
    <div>
      <Subtitle>{title}</Subtitle>
      <TableWrapper>
        <StyledTable>
          <thead>
            <tr>
              <TableHeader>Line Item</TableHeader>
              {headers.map((header, index) => (
                <TableHeader key={index}>{header}</TableHeader>
              ))}
            </tr>
          </thead>
          <tbody>
            {dataKeys.map(key => (
              <TableRow key={key}>
                {/* Format the key name to be more readable (e.g., "netIncome" -> "Net Income") */}
                <TableCell>{key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}</TableCell>
                {data.map((row, index) => (
                  <TableCell key={index}>{formatNumber(row[key], currencySymbol)}</TableCell>
                ))}
              </TableRow>
            ))}
          </tbody>
        </StyledTable>
      </TableWrapper>
    </div>
  );
};

export default StatementTable;
</file>

<file path="frontend/src/components/Forecasts/AnalystRating.js">
import React, { useMemo } from 'react';
import styled from 'styled-components';
import GaugeChart from 'react-gauge-chart';

//...(Styled components are unchanged)...
const RatingContainer = styled.div`
  width: 100%;
`;
const SectionTitle = styled.h3`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 2rem;
  color: var(--color-text-primary);
`;
const GaugeWrapper = styled.div`
  max-width: 450px;
  margin: 0 auto;
`;
const RatingText = styled.div`
  font-size: 1.8rem;
  font-weight: 700;
  text-align: center;
  margin-top: -40px;
  color: ${({ color }) => color};
`;
const BreakdownList = styled.div`
  margin-top: 2.5rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
`;
const BreakdownItem = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
`;
const BreakdownLabel = styled.span`
  font-size: 1rem;
  color: var(--color-text-secondary);
  width: 100px;
`;
const BreakdownBarContainer = styled.div`
  flex-grow: 1;
  height: 8px;
  background-color: var(--color-border);
  border-radius: 4px;
  margin: 0 1rem;
`;
const BreakdownBar = styled.div`
  height: 100%;
  width: ${({ percent }) => percent}%;
  background-color: ${({ color }) => color};
  border-radius: 4px;
  transition: width 0.5s ease-out;
`;
const BreakdownValue = styled.span`
  font-size: 1rem;
  font-weight: 600;
  color: var(--color-text-primary);
  width: 30px;
  text-align: right;
`;


const AnalystRating = ({ ratingsData }) => {
  const processedRatings = useMemo(() => {
    // MORE ROBUST CHECK: Ensure the array exists and has content.
    if (!ratingsData || !Array.isArray(ratingsData) || ratingsData.length === 0) {
      return null;
    }

    const ratingMap = {
      'strongSell': { count: 0, text: 'Strong Sell', color: '#F85149' },
      'sell': { count: 0, text: 'Sell', color: '#F88149' },
      'hold': { count: 0, text: 'Hold', color: '#EDBB5A' },
      'buy': { count: 0, text: 'Buy', color: '#3FB950' },
      'strongBuy': { count: 0, text: 'Strong Buy', color: '#17C3B2' },
    };

    let totalAnalysts = 0;

    // The FMP API gives the breakdown directly in the first object of the array
    const latestRatingData = ratingsData[0];
    
    ratingMap.strongSell.count = latestRatingData.ratingStrongSell || 0;
    ratingMap.sell.count = latestRatingData.ratingSell || 0;
    ratingMap.hold.count = latestRatingData.ratingHold || 0;
    ratingMap.buy.count = latestRatingData.ratingBuy || 0;
    ratingMap.strongBuy.count = latestRatingData.ratingStrongBuy || 0;

    totalAnalysts = Object.values(ratingMap).reduce((sum, item) => sum + item.count, 0);
    
    // FINAL GUARD: If after all that, we have no analysts, return null.
    if (totalAnalysts === 0) return null;

    let totalScore = 0;
    totalScore += ratingMap.strongSell.count * 1;
    totalScore += ratingMap.sell.count * 2;
    totalScore += ratingMap.hold.count * 3;
    totalScore += ratingMap.buy.count * 4;
    totalScore += ratingMap.strongBuy.count * 5;

    const averageScore = totalScore / totalAnalysts;
    const gaugePercent = (averageScore - 1) / 4;

    let consensusText = 'Hold';
    let consensusColor = ratingMap.hold.color;
    if (averageScore > 4.5) { consensusText = 'Strong Buy'; consensusColor = ratingMap.strongBuy.color; }
    else if (averageScore > 3.5) { consensusText = 'Buy'; consensusColor = ratingMap.buy.color; }
    else if (averageScore < 2.5) { consensusText = 'Sell'; consensusColor = ratingMap.sell.color; }
    else if (averageScore < 1.5) { consensusText = 'Strong Sell'; consensusColor = ratingMap.strongSell.color; }

    return {
      totalAnalysts,
      gaugePercent,
      consensusText,
      consensusColor,
      breakdown: Object.values(ratingMap).reverse(),
    };
  }, [ratingsData]);

  if (!processedRatings) {
    return (
      <RatingContainer>
        <SectionTitle>Analyst Rating</SectionTitle>
        <p>Analyst rating data is not available for this stock.</p>
      </RatingContainer>
    );
  }

  const { totalAnalysts, gaugePercent, consensusText, consensusColor, breakdown } = processedRatings;

  return (
    <RatingContainer>
      <SectionTitle>Analyst Rating</SectionTitle>
      <p style={{ color: 'var(--color-text-secondary)', marginTop: '-1.5rem', marginBottom: '2rem' }}>
          Based on {totalAnalysts} analysts giving stock ratings in the past 3 months.
      </p>

      <GaugeWrapper>
        <GaugeChart id="analyst-rating-gauge" nrOfLevels={5} arcsLength={[0.2, 0.15, 0.3, 0.15, 0.2]} colors={['#F85149', '#F88149', '#EDBB5A', '#3FB950', '#17C3B2']} percent={gaugePercent} arcPadding={0.02} cornerRadius={3} textColor={'transparent'} needleBaseColor={'#FFFFFF'} needleColor={'#C9D1D9'} />
        <RatingText color={consensusColor}>{consensusText}</RatingText>
      </GaugeWrapper>

      <BreakdownList>
        {breakdown.map(item => (
          <BreakdownItem key={item.text}>
            <BreakdownLabel>{item.text}</BreakdownLabel>
            <BreakdownBarContainer>
              <BreakdownBar percent={(item.count / totalAnalysts) * 100} color={item.color} />
            </BreakdownBarContainer>
            <BreakdownValue>{item.count}</BreakdownValue>
          </BreakdownItem>
        ))}
      </BreakdownList>
    </RatingContainer>
  );
};

export default AnalystRating;
</file>

<file path="frontend/src/components/Fundamentals/BenjaminGrahamScan.js">
import React from 'react';
import styled from 'styled-components';

// --- Styled Components (reusing our professional styles) ---

const SectionContainer = styled.div`
  /* Main container for this scan */
`;

const SectionTitle = styled.h3`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 1.5rem;
  color: var(--color-text-primary);
`;

const ScanGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 2fr;
  gap: 2rem;
  align-items: center;

  @media (max-width: 768px) {
    grid-template-columns: 1fr;
  }
`;

const ScoreCard = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 2rem;
  background-color: var(--color-background);
  border-radius: 50%;
  width: 180px;
  height: 180px;
  border: 4px solid ${({ scoreColor }) => scoreColor};
  margin: 0 auto;
`;

const ScoreValue = styled.span`
  font-size: 4rem;
  font-weight: 800;
  color: ${({ scoreColor }) => scoreColor};
`;

const ScoreLabel = styled.span`
  font-size: 1rem;
  font-weight: 500;
  color: var(--color-text-secondary);
`;

const CriteriaList = styled.ul`
  list-style-type: none;
  padding-left: 0;
`;

const CriteriaListItem = styled.li`
  margin-bottom: 0.75rem;
  color: var(--color-text-primary);
  display: flex;
  align-items: center;
  line-height: 1.6;

  &::before {
    content: '✓';
    color: var(--color-success);
    margin-right: 12px;
    font-size: 1.2rem;
    font-weight: bold;
  }
`;

// --- The React Component ---

const BenjaminGrahamScan = ({ scanData }) => {
  // If we don't have the data from the backend, show an informative message.
  if (!scanData || !scanData.criteria) {
    return (
      <SectionContainer>
        <SectionTitle>Benjamin Graham Scan</SectionTitle>
        <p>Graham scan data is not available or could not be calculated.</p>
      </SectionContainer>
    );
  }

  const { score, criteria } = scanData;

  // Determine the color based on the score (0-2 Red, 3-5 Yellow, 6-7 Green)
  const getScoreColor = () => {
    if (score >= 6) return 'var(--color-success)';
    if (score >= 3) return '#EDBB5A'; // Neutral Yellow
    return 'var(--color-danger)';
  };
  const scoreColor = getScoreColor();

  return (
    <SectionContainer>
      <SectionTitle>Benjamin Graham Scan</SectionTitle>
      <ScanGrid>
        <ScoreCard scoreColor={scoreColor}>
          <ScoreValue scoreColor={scoreColor}>{score}</ScoreValue>
          <ScoreLabel>/ 7 Tenets</ScoreLabel>
        </ScoreCard>
        <div>
          <p style={{ color: 'var(--color-text-secondary)', marginBottom: '1.5rem', lineHeight: 1.6 }}>
            A checklist for the "defensive investor" based on the principles of the father of value investing. A high score suggests a stable, reasonably priced company.
          </p>
          <CriteriaList>
            {criteria.map((item, index) => (
              <CriteriaListItem key={index}>{item}</CriteriaListItem>
            ))}
          </CriteriaList>
        </div>
      </ScanGrid>
    </SectionContainer>
  );
};

export default BenjaminGrahamScan;
</file>

<file path="frontend/src/components/Indices/IndicesBanner.js">
import React, { useState, useEffect } from 'react';
import styled, { keyframes } from 'styled-components';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

// --- Styled Components & Animations ---

const fadeIn = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;

const BannerContainer = styled.div`
  width: 100%;
  padding: 1.5rem 0;
  margin-bottom: 3rem;
  overflow: hidden; /* Important for the scrolling animation */
`;

const CardScroller = styled.div`
  display: flex;
  gap: 1rem;
  /* Allows horizontal scrolling on smaller screens or if there are many cards */
  overflow-x: auto;
  padding-bottom: 1rem; /* Space for the scrollbar */

  /* Hide scrollbar for a cleaner look, but keep functionality */
  &::-webkit-scrollbar {
    display: none;
  }
  -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */
`;

const IndexCard = styled.div`
  flex-shrink: 0; /* Prevents cards from shrinking */
  width: 220px;
  padding: 1rem;
  background-color: var(--color-secondary);
  border: 1px solid var(--color-border);
  border-radius: 12px;
  cursor: pointer;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  animation: ${fadeIn} 0.5s ease-out;

  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
  }
`;

const IndexName = styled.h3`
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--color-text-primary);
  white-space: nowrap;
`;

const IndexPrice = styled.div`
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--color-text-primary);
  margin: 0.5rem 0;
`;

const IndexChange = styled.div`
  font-size: 1rem;
  font-weight: 500;
  color: ${({ isPositive }) => (isPositive ? 'var(--color-success)' : 'var(--color-danger)')};
`;


// --- The React Component ---

const IndicesBanner = () => {
  const [indices, setIndices] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const navigate = useNavigate();

  // This is the core logic for fetching and auto-refreshing the data
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get('/api/indices/summary');
        setIndices(response.data);
      } catch (error) {
        console.error("Failed to fetch indices summary:", error);
      } finally {
        // Only set loading to false on the first fetch
        if (isLoading) {
            setIsLoading(false);
        }
      }
    };

    fetchData(); // Fetch immediately on component mount

    // --- The "Live Ticking" Polling ---
    // Set up an interval to re-fetch the data every 10 seconds
    const intervalId = setInterval(fetchData, 10000);

    // This is a cleanup function. React runs this when the component is unmounted
    // to prevent memory leaks by stopping the interval.
    return () => clearInterval(intervalId);
  }, [isLoading]); // Rerun effect if isLoading changes (though it won't)

  const handleCardClick = (symbol) => {
    // URL-encode the symbol to handle special characters like '^'
    const encodedSymbol = encodeURIComponent(symbol);
    // We will build this page in the next big step
    navigate(`/index/${encodedSymbol}`);
  };

  if (isLoading) {
    return <BannerContainer><p style={{ textAlign: 'center' }}>Loading market data...</p></BannerContainer>;
  }

  if (!indices || indices.length === 0) {
    return null; // Don't render anything if there's no data or an error
  }

  return (
    <BannerContainer>
      <CardScroller>
        {indices.map(index => {
          const isPositive = index.change >= 0;
          return (
            <IndexCard key={index.symbol} onClick={() => handleCardClick(index.symbol)}>
              <IndexName>{index.name}</IndexName>
              <IndexPrice>{index.price.toFixed(2)}</IndexPrice>
              <IndexChange isPositive={isPositive}>
                {isPositive ? '+' : ''}{index.change.toFixed(2)} ({isPositive ? '+' : ''}{index.percent_change.toFixed(2)}%)
              </IndexChange>
            </IndexCard>
          );
        })}
      </CardScroller>
    </BannerContainer>
  );
};

export default IndicesBanner;
</file>

<file path="frontend/src/components/News/NewsList.js">
import React from 'react';
import styled from 'styled-components';
import Card from '../common/Card';

// --- Styled Components ---

const NewsListContainer = styled.ul`
  list-style-type: none;
  padding: 0;
  margin: 0;
  /* Allows the list to scroll if it's too long */
  max-height: 500px;
  overflow-y: auto;
`;

const NewsItem = styled.li`
  padding: 1rem 0.5rem;
  border-bottom: 1px solid var(--color-border);
  
  &:last-child {
    border-bottom: none; /* Remove border for the last item */
  }
`;

const NewsLink = styled.a`
  text-decoration: none;
  color: var(--color-text-primary);
  transition: color 0.2s ease;

  &:hover {
    color: var(--color-primary);
  }
`;

const NewsTitle = styled.h4`
  font-size: 1rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
`;

const NewsMeta = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.8rem;
  color: var(--color-text-secondary);
`;

// --- Helper Function ---

// Formats the ISO date string into a more readable format, e.g., "Nov 08, 2025"
const formatDate = (isoString) => {
  if (!isoString) return '';
  const date = new Date(isoString);
  return date.toLocaleDateString('en-US', {
    month: 'short',
    day: '2-digit',
    year: 'numeric',
  });
};


// --- React Component ---

const NewsList = ({ newsArticles }) => {

  // Defensive check: If there are no articles, show a message.
  if (!newsArticles || !Array.isArray(newsArticles) || newsArticles.length === 0) {
    return (
      <Card title="Latest News">
        <p>No recent news found for this company.</p>
      </Card>
    );
  }

  return (
    <Card title="Latest News">
      <NewsListContainer>
        {/* We'll show the top 15 articles */}
        {newsArticles.slice(0, 15).map((article, index) => (
          <NewsItem key={index}>
            <NewsLink href={article.url} target="_blank" rel="noopener noreferrer">
              <NewsTitle>{article.title}</NewsTitle>
              <NewsMeta>
                <span>{article.source.name}</span>
                <span>{formatDate(article.publishedAt)}</span>
              </NewsMeta>
            </NewsLink>
          </NewsItem>
        ))}
      </NewsListContainer>
    </Card>
  );
};

export default NewsList;
</file>

<file path="frontend/src/components/Sentiment/OverallSentiment.js">
import React from 'react';
import styled from 'styled-components';
import GaugeChart from 'react-gauge-chart';
import Card from '../common/Card';

// --- Styled Components for an "Extreme Graphics" Dial ---

const SentimentContainer = styled.div`
  width: 100%;
  padding: 1rem;
`;

const GaugeWrapper = styled.div`
  width: 100%;
  max-width: 350px;
  margin: 0 auto;
`;

const VerdictText = styled.div`
  font-size: 2.2rem;
  font-weight: 800;
  text-align: center;
  margin-top: -50px; /* Pull the text up into the gauge */
  color: ${({ color }) => color};
  text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
`;

const ScoreText = styled.div`
  font-size: 1rem;
  font-weight: 500;
  text-align: center;
  color: var(--color-text-secondary);
  margin-top: 5px;
`;

// --- The React Component ---

const OverallSentiment = ({ sentimentData }) => {
  if (!sentimentData) {
    return (
      <Card title="Overall Sentiment">
        <p>Sentiment data could not be calculated.</p>
      </Card>
    );
  }

  const { score, verdict } = sentimentData;

  // Convert the 0-100 score to a 0-1 percentage for the gauge
  const gaugePercent = score / 100;

  // Determine the color for the verdict text based on the score
  const getVerdictColor = () => {
    if (score > 75) return 'var(--color-success)';
    if (score > 60) return '#34D399'; // A lighter green
    if (score < 25) return 'var(--color-danger)';
    if (score < 40) return '#F87171'; // A lighter red
    return '#EDBB5A'; // Neutral Yellow
  };
  const verdictColor = getVerdictColor();

  return (
    <Card title="Overall Sentiment">
      <SentimentContainer>
        <GaugeWrapper>
          <GaugeChart
            id="sentiment-gauge"
            nrOfLevels={40}
            arcsLength={[0.2, 0.2, 0.2, 0.2, 0.2]} // 5 equal sections
            colors={['#F85149', '#F88149', '#EDBB5A', '#3FB950', '#17C3B2']}
            percent={gaugePercent}
            arcPadding={0.02}
            cornerRadius={3}
            textColor={'transparent'} // Hide the default percentage
            needleBaseColor={'#FFFFFF'}
            needleColor={'#C9D1D9'}
            animate={true}
            animDelay={500}
          />
          <VerdictText color={verdictColor}>{verdict}</VerdictText>
          <ScoreText>Score: {score.toFixed(0)} / 100</ScoreText>
        </GaugeWrapper>
      </SentimentContainer>
    </Card>
  );
};

export default OverallSentiment;
</file>

<file path="frontend/src/components/Shareholding/OwnershipTrend.js">
import React from 'react';
import styled from 'styled-components';
import {
  AreaChart,
  Area,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  CartesianGrid
} from 'recharts';

// --- Styled Components ---

const ChartContainer = styled.div`
  width: 100%;
  height: 400px;
  margin-top: 3rem;
  padding-top: 2rem;
  border-top: 1px solid var(--color-border);
`;

const SectionTitle = styled.h3`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 1.5rem;
  color: var(--color-text-primary);
`;

const CustomTooltipContainer = styled.div`
  background-color: #2a3441;
  border: 1px solid var(--color-border);
  padding: 1rem;
  border-radius: 8px;
  color: var(--color-text-primary);
`;


// --- The New, Smarter React Component ---

const OwnershipTrend = ({ historicalStatements }) => {
  // We now use the 'annual_revenue_and_profit' data (which is the income statements array)
  // as it contains the historical shares outstanding.
  if (!historicalStatements || !Array.isArray(historicalStatements) || historicalStatements.length < 2) {
    return (
      <ChartContainer>
        <SectionTitle>Shares Outstanding Trend</SectionTitle>
        <p>Historical shares data is not available for this stock.</p>
      </ChartContainer>
    );
  }

  // Helper function to format large numbers into Billions (B) or Millions (M)
  const formatLargeNumber = (num) => {
    if (!num || isNaN(num)) return 'N/A';
    if (Math.abs(num) >= 1e9) return `${(num / 1e9).toFixed(2)}B`;
    if (Math.abs(num) >= 1e6) return `${(num / 1e6).toFixed(2)}M`;
    return num.toLocaleString();
  };

  // Process the income statement data to extract the year and shares outstanding
  const chartData = historicalStatements
    .slice() // Create a copy to avoid mutating the original prop
    .reverse() // Reverse to show chronological order (oldest to newest)
    .map(item => ({
      year: item.calendarYear,
      'Shares Outstanding': item.weightedAverageShsOut,
    }));

  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      return (
        <CustomTooltipContainer>
          <p style={{ fontWeight: 'bold' }}>Year: {label}</p>
          <p style={{ color: 'var(--color-primary)' }}>
            Shares: {formatLargeNumber(payload[0].value)}
          </p>
        </CustomTooltipContainer>
      );
    }
    return null;
  };

  return (
    <ChartContainer>
      <SectionTitle>Shares Outstanding Trend</SectionTitle>
      <ResponsiveContainer width="100%" height="100%">
        <AreaChart
          data={chartData}
          margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke="var(--color-border)" />
          <XAxis 
            dataKey="year" 
            stroke="var(--color-text-secondary)" 
            tick={{ fill: 'var(--color-text-secondary)', fontSize: 12 }} 
          />
          <YAxis 
            stroke="var(--color-text-secondary)" 
            tickFormatter={formatLargeNumber}
            tick={{ fill: 'var(--color-text-secondary)', fontSize: 12 }}
            domain={['dataMin - 1000000', 'dataMax + 1000000']} // Add some padding
          />
          <Tooltip content={<CustomTooltip />} />
          <Area 
            type="monotone" 
            dataKey="Shares Outstanding" 
            stroke="var(--color-primary)" 
            fill="rgba(88, 166, 255, 0.2)" // A nice semi-transparent fill
            strokeWidth={2}
          />
        </AreaChart>
      </ResponsiveContainer>
    </ChartContainer>
  );
};

export default OwnershipTrend;
</file>

<file path="frontend/src/components/Shareholding/TrendChart.js">
import React from 'react';
import styled from 'styled-components';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  CartesianGrid,
  Cell
} from 'recharts';

// --- Styled Components ---

const ChartWrapper = styled.div`
  width: 100%;
  height: 350px;
`;

const ChartTitle = styled.h3`
  text-align: center;
  color: var(--color-text-secondary);
  font-weight: 500;
  margin-bottom: 2rem;
`;

// --- React Component ---

const TrendChart = () => {
  // --- Placeholder Data ---
  // The free API does not provide this historical data,
  // so we are using a realistic placeholder structure to build the UI.
  const placeholderData = [
    { name: 'Jun 2024', Holding: 13.27, Pledges: 0 },
    { name: 'Sep 2024', Holding: 13.25, Pledges: 0 },
    { name: 'Dec 2024', Holding: 13.25, Pledges: 0 },
    { name: 'Jun 2025', Holding: 11.74, Pledges: 0 },
    { name: 'Sep 2025', Holding: 11.73, Pledges: 0 },
  ];

  // Custom Tooltip for better styling
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      return (
        <div style={{
            backgroundColor: 'var(--color-secondary)',
            border: '1px solid var(--color-border)',
            padding: '10px',
            borderRadius: '5px'
        }}>
          <p>{label}</p>
          <p style={{ color: '#8884d8' }}>{`Holding: ${payload[0].value}%`}</p>
          <p style={{ color: '#82ca9d' }}>{`Pledged: ${payload[1] ? payload[1].value : '0'}%`}</p>
        </div>
      );
    }
    return null;
  };

  return (
    <ChartWrapper>
      <ChartTitle>Promoter Holding Trend (%)</ChartTitle>
      <ResponsiveContainer>
        <BarChart
          data={placeholderData}
          margin={{ top: 5, right: 20, left: 0, bottom: 5 }}
        >
          <CartesianGrid strokeDasharray="3 3" stroke="var(--color-border)" vertical={false} />
          <XAxis 
            dataKey="name" 
            stroke="var(--color-text-secondary)" 
            tick={{ fill: 'var(--color-text-secondary)', fontSize: 12 }} 
          />
          <YAxis 
            stroke="var(--color-text-secondary)" 
            domain={[0, 15]} // Set a fixed domain for better visual consistency
            tick={{ fill: 'var(--color-text-secondary)', fontSize: 12 }} 
          />
          <Tooltip content={<CustomTooltip />} cursor={{ fill: 'rgba(136, 132, 216, 0.1)' }} />
          
          {/* Bar for Promoter Holding */}
          <Bar dataKey="Holding" fill="#586994" barSize={30}>
            {placeholderData.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={entry.Holding < 12 ? '#FE6D73' : '#586994'} />
            ))}
          </Bar>
          
          {/* Bar for Pledged shares. It will stack on top of the Holding bar.
              Since our pledges are 0, it won't be visible, which is correct. */}
          <Bar dataKey="Pledges" stackId="a" fill="#3FB950" />
        </BarChart>
      </ResponsiveContainer>
    </ChartWrapper>
  );
};

export default TrendChart;
</file>

<file path="frontend/src/index.js">
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

// Find the div with the id of 'root' in the index.html file
const rootElement = document.getElementById('root');

// Create a root for our React application to render into
const root = ReactDOM.createRoot(rootElement);

// Render the main App component
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="frontend/src/pages/IndexDetailPage.js">
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import styled, { keyframes } from 'styled-components';
import axios from 'axios';

// --- (Imports are unchanged) ---
import StockHeader from '../components/Header/StockHeader';
import Technicals from '../components/Technicals/Technicals';
import TradingViewChart from '../components/Chart/TradingViewChart';
import { Tabs, TabPanel } from '../components/common/Tabs/Tabs';

// --- (Styled Components are unchanged) ---
const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

const DetailPageContainer = styled.div`
  padding: 2rem 3rem;
  max-width: 1800px;
  margin: 0 auto;
  animation: ${fadeIn} 0.5s ease-in;
`;

const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 90vh;
  color: var(--color-primary);
  font-size: 1.5rem;
`;

const ErrorContainer = styled(LoadingContainer)`
  color: var(--color-danger);
`;

const BackButton = styled.button`
  background: none;
  border: 1px solid var(--color-border);
  color: var(--color-text-secondary);
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9rem;
  margin-bottom: 2rem;
  transition: all 0.2s ease;
  &:hover {
    background-color: var(--color-secondary);
    color: var(--color-text-primary);
  }
`;

// --- The Updated React Component ---

const IndexDetailPage = () => {
  const { encodedSymbol } = useParams();
  const navigate = useNavigate();

  const [staticData, setStaticData] = useState(null);
  const [liveQuote, setLiveQuote] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  const symbol = decodeURIComponent(encodedSymbol);

  useEffect(() => {
    const fetchIndexDetails = async () => {
      if (!encodedSymbol) return;
      setIsLoading(true);
      setError(null);
      try {
        const response = await axios.get(`/api/indices/${encodedSymbol}/details`);
        setStaticData(response.data);
        setLiveQuote(response.data.quote); 
      } catch (err) {
        console.error("Failed to fetch index details:", err);
        setError(`Could not retrieve data for ${symbol}. Please try again.`);
      } finally {
        setIsLoading(false);
      }
    };
    fetchIndexDetails();
  }, [encodedSymbol, symbol]);

  useEffect(() => {
    if (!staticData) return;
    const fetchLivePrice = async () => {
      try {
        const response = await axios.get(`/api/indices/${encodedSymbol}/live-price`);
        setLiveQuote(response.data);
      } catch (error) {
        console.error("Failed to fetch live index price:", error);
      }
    };
    fetchLivePrice();
    const intervalId = setInterval(fetchLivePrice, 10000);
    return () => clearInterval(intervalId);
  }, [staticData, encodedSymbol]);

  if (isLoading) {
    return <LoadingContainer><p>Loading market data for {symbol}...</p></LoadingContainer>;
  }

  if (error || !staticData) {
    return (
      <ErrorContainer>
        <h2>An Error Occurred</h2>
        <p>{error || `Could not retrieve data for ${symbol}.`}</p>
        <BackButton style={{ marginTop: '2rem' }} onClick={() => navigate('/')}>Go Back Home</BackButton>
      </ErrorContainer>
    );
  }

  // --- THIS IS THE CRITICAL FIX ---
  // We get the correct TradingView symbol from our new, intelligent profile object.
  // We use the original 'symbol' as a fallback, just in case.
  const tradingViewSymbol = staticData.profile?.tradingview_symbol || symbol;

  return (
    <DetailPageContainer>
      <BackButton onClick={() => navigate('/')}>
        &larr; Back to Home
      </BackButton>

      <StockHeader profile={staticData.profile} quote={liveQuote} />
      
      <Tabs>
        <TabPanel label="Overview">
            {/* We now pass the new, correct symbol to the chart */}
            <TradingViewChart symbol={tradingViewSymbol} />
        </TabPanel>
        
        <TabPanel label="Technicals">
            <Technicals
                analystRatings={staticData.analyst_ratings}
                technicalIndicators={staticData.technical_indicators}
            />
        </TabPanel>
      </Tabs>

    </DetailPageContainer>
  );
};

export default IndexDetailPage;
</file>

<file path="requirements.txt">

</file>

<file path="backend/app/routers/charts.py">
from fastapi import APIRouter, UploadFile, File, HTTPException
from ..services import gemini_service, yahoo_service, technical_service
import asyncio

router = APIRouter()

# Define the timeframes we want and the amount of data needed for them
TIMEFRAMES_CONFIG = {
    "5m": "5d",    # 5 minutes, last 5 days
    "15m": "10d",  # 15 minutes, last 10 days
    "30m": "1mo",  # 30 minutes, last 1 month
    "1h": "1mo",   # 1 hour, last 1 month
    "4h": "3mo",   # 4 hours, last 3 months
    "1d": "1y",    # Daily, last 1 year
    "1w": "2y",    # Weekly, last 2 years
    "1mo": "5y"    # Monthly, last 5 years
}

@router.post("/analyze")
async def analyze_chart_image(chart_image: UploadFile = File(...)):
    """
    Master endpoint:
    1. Visual AI Analysis of the image.
    2. Symbol Detection.
    3. Multi-Timeframe Technical Data Calculation.
    """
    print("Received chart image for analysis...")

    if not chart_image.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="Invalid file type. Please upload an image.")

    image_bytes = await chart_image.read()

    # --- Step 1: Identify Symbol (AI) ---
    print("Task 1: Identifying symbol...")
    identified_symbol = await asyncio.to_thread(gemini_service.identify_ticker_from_image, image_bytes)

    if not identified_symbol or identified_symbol == "NOT_FOUND":
        return {"identified_symbol": "NOT_FOUND", "analysis_data": None, "technical_data": None}
    
    print(f"Symbol identified: {identified_symbol}")

    # --- Step 2: Visual Analysis (AI) ---
    print("Task 2: Performing visual analysis...")
    analysis_task = asyncio.to_thread(gemini_service.analyze_chart_technicals_from_image, image_bytes)

    # --- Step 3: Multi-Timeframe Data Fetching (Math) ---
    print("Task 3: Fetching multi-timeframe data...")
    
    async def fetch_and_calculate(tf, period):
        # Fetch history
        df = await asyncio.to_thread(yahoo_service.get_historical_data, identified_symbol, period, tf)
        # Calculate indicators
        return tf, technical_service.calculate_extended_technicals(df)

    # Create tasks for all timeframes
    technical_tasks = [fetch_and_calculate(tf, period) for tf, period in TIMEFRAMES_CONFIG.items()]

    # Run AI and Data tasks concurrently for maximum speed
    results = await asyncio.gather(analysis_task, *technical_tasks)

    # Unpack results
    analysis_data = results[0] # The AI text result
    technical_results = results[1:] # The list of (timeframe, data) tuples

    # Convert technical results into a clean dictionary
    technical_data = {tf: data for tf, data in technical_results if data is not None}

    return {
        "identified_symbol": identified_symbol,
        "analysis_data": analysis_data,
        "technical_data": technical_data # The new power feature
    }
</file>

<file path="frontend/src/App.js">
import React from 'react';
import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
import { GlobalStyles } from './styles/GlobalStyles';
import HomePage from './pages/HomePage';
import StockDetailPage from './pages/StockDetailPage';
// --- NEW: Import our new Index Detail Page ---
import IndexDetailPage from './pages/IndexDetailPage';

function App() {
  return (
    <>
      {/* This component injects our beautiful dark theme styles into the entire app */}
      <GlobalStyles />

      {/* The Router handles all page navigation */}
      <Router>
        <Routes>
          {/* Route for the main landing/search page */}
          <Route path="/" element={<HomePage />} />

          {/* Route for the detailed stock analysis page */}
          <Route path="/stock/:symbol" element={<StockDetailPage />} />

          {/* --- NEW ROUTE ADDED HERE --- */}
          {/* Route for the detailed index analysis page. 
              The ":encodedSymbol" will hold the URL-safe version of the index symbol. */}
          <Route path="/index/:encodedSymbol" element={<IndexDetailPage />} />

        </Routes>
      </Router>
    </>
  );
}

export default App;
</file>

<file path="frontend/src/components/common/Card.js">
import React from 'react';
import styled from 'styled-components';

// This is our master styled component for all content blocks.
const CardContainer = styled.div`
  background-color: var(--color-secondary);
  border: 1px solid var(--color-border);
  border-radius: 12px;
  margin-bottom: 1.5rem; 
  width: 100%;
  
  /* Mobile: Tight padding */
  padding: 1rem; 

  /* Desktop: Luxurious padding */
  @media (min-width: 768px) {
    padding: 2rem;
    margin-bottom: 2rem;
    
  }
`;

const CardHeader = styled.div`
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 1px solid var(--color-border);
`;

const CardTitle = styled.h2`
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--color-text-primary);
`;

const CardContent = styled.div`
  /* The content inside the card will be placed here */
`;

// This is a reusable React component that accepts a title and content.
const Card = ({ title, children }) => {
  return (
    <CardContainer>
      {/* The title is optional; if a title is provided, the header will render. */}
      {title && (
        <CardHeader>
          <CardTitle>{title}</CardTitle>
        </CardHeader>
      )}
      <CardContent>
        {/* 'children' is a special prop in React that lets us pass components inside other components.
            Whatever we place inside <Card>...</Card> will be rendered here. */}
        {children}
      </CardContent>
    </CardContainer>
  );
};

export default Card;
</file>

<file path="frontend/src/components/common/Tabs/NestedTabs.js">
import React, { useState, useRef } from 'react';
import styled from 'styled-components';
import { FaChevronLeft, FaChevronRight } from 'react-icons/fa';

// --- Styled Components ---

const TabsContainer = styled.div`
  width: 100%;
  position: relative;
`;

const TabListWrapper = styled.div`
  position: relative;
  display: flex;
  align-items: center;
  border-bottom: 1px solid var(--color-border);
  margin-bottom: 2rem;
`;

const TabList = styled.div`
  display: flex;
  overflow-x: auto;
  scroll-behavior: smooth;
  width: 100%;
  
  &::-webkit-scrollbar {
    display: none;
  }
  -ms-overflow-style: none;
  scrollbar-width: none;
`;

const TabButton = styled.button`
  padding: 0.75rem 1.25rem;
  border: none;
  background-color: transparent;
  color: ${({ active }) => (active ? 'var(--color-primary)' : 'var(--color-text-secondary)')};
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  position: relative;
  transition: color 0.3s ease, background-color 0.3s ease;
  border-radius: 6px 6px 0 0;
  margin-bottom: -1px;
  border: 1px solid transparent;
  white-space: nowrap; /* Critical for scrolling */
  flex-shrink: 0;      /* Critical for scrolling */

  &:hover {
    background-color: var(--color-secondary);
  }

  ${({ active }) => active && `
    background-color: var(--color-secondary);
    border-color: var(--color-border) var(--color-border) transparent var(--color-border);
  `}
`;

// Reusing the same arrow logic for consistency
const ScrollButton = styled.button`
  position: absolute;
  top: 0;
  bottom: 0;
  width: 30px; /* Slightly smaller for nested tabs */
  border: none;
  cursor: pointer;
  z-index: 2;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--color-text-secondary);
  font-size: 0.8rem;
  transition: opacity 0.2s;
  
  &.left {
    left: 0;
    background: linear-gradient(to right, var(--color-secondary) 40%, transparent 100%);
  }
  
  &.right {
    right: 0;
    background: linear-gradient(to left, var(--color-secondary) 40%, transparent 100%);
  }

  &:hover {
    color: var(--color-primary);
  }
`;

const TabContent = styled.div`
  padding: 1rem 0;
`;

// --- The Logic ---

const NestedTabs = ({ children }) => {
  const [activeTab, setActiveTab] = useState(children[0].props.label);
  const scrollRef = useRef(null);

  const handleClick = (e, newActiveTab) => {
    e.preventDefault();
    setActiveTab(newActiveTab);
    e.target.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
  };

  const scroll = (direction) => {
    if (scrollRef.current) {
      const { current } = scrollRef;
      const scrollAmount = 150;
      if (direction === 'left') {
        current.scrollLeft -= scrollAmount;
      } else {
        current.scrollLeft += scrollAmount;
      }
    }
  };

  return (
    <TabsContainer>
      <TabListWrapper>
        <ScrollButton className="left" onClick={() => scroll('left')}><FaChevronLeft /></ScrollButton>
        
        <TabList ref={scrollRef}>
          {children.map(child => (
            <TabButton
              key={child.props.label}
              active={activeTab === child.props.label}
              onClick={e => handleClick(e, child.props.label)}
            >
              {child.props.label}
            </TabButton>
          ))}
        </TabList>

        <ScrollButton className="right" onClick={() => scroll('right')}><FaChevronRight /></ScrollButton>
      </TabListWrapper>

      <TabContent>
        {children.map(child => {
          if (child.props.label === activeTab) {
            return <div key={child.props.label}>{child.props.children}</div>;
          }
          return null;
        })}
      </TabContent>
    </TabsContainer>
  );
};

const NestedTabPanel = ({ label, children }) => {
  return <div label={label}>{children}</div>;
};

export { NestedTabs, NestedTabPanel };
</file>

<file path="frontend/src/components/Forecasts/PriceTarget.js">
import React from 'react';
import styled from 'styled-components';
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  ReferenceLine,
  Label
} from 'recharts';

// --- Styled Components ---

const PriceTargetContainer = styled.div`
  width: 100%;
`;

const SectionTitle = styled.h3`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
  color: var(--color-text-primary);
`;

const PriceDisplay = styled.div`
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: 0.25rem;
`;

const PriceChange = styled.div`
  font-size: 1rem;
  font-weight: 500;
  color: ${({ isPositive }) => (isPositive ? 'var(--color-success)' : 'var(--color-danger)')};
  margin-bottom: 1rem;
`;

const SummaryText = styled.p`
  color: var(--color-text-secondary);
  line-height: 1.6;
  max-width: 400px;
  margin-bottom: 2rem;
`;

const ChartWrapper = styled.div`
  height: 400px;
  width: 100%;
`;

// --- NEW: The same intelligent currency helper function from our StockHeader ---
const getCurrencySymbol = (currencyCode) => {
    switch (currencyCode) {
        case 'INR':
            return '₹';
        case 'USD':
            return '$';
        case 'JPY':
            return '¥';
        // We can add more currencies like EUR, GBP etc. as needed in the future
        default:
            return '$'; // Default to dollar if the currency code is unknown or missing
    }
};

// --- The Upgraded, Currency-Aware React Component ---

// The component now accepts the 'currency' prop from its parent.
const PriceTarget = ({ consensus, quote, currency }) => {

  // Defensive check: If essential data is missing, we show an informative message.
  if (!consensus || !quote || !consensus.targetConsensus) {
    return (
      <PriceTargetContainer>
        <SectionTitle>Price Target</SectionTitle>
        <p>Price target data is not available for this stock.</p>
      </PriceTargetContainer>
    );
  }
  
  // --- Get the correct currency symbol based on the data received ---
  const currencySymbol = getCurrencySymbol(currency);

  const { targetHigh, targetLow, targetConsensus } = consensus;
  const currentPrice = quote.price;

  const change = targetConsensus - currentPrice;
  const changePercent = (change / currentPrice) * 100;
  const isPositive = change >= 0;

  // Data for the simple line chart visualization
  const chartData = [
    { name: 'Current', value: currentPrice },
    { name: '1Y Forecast', value: targetConsensus },
  ];
  
  // A custom tooltip for better styling that also includes the currency symbol
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      return (
        <div style={{
          backgroundColor: 'var(--color-secondary)',
          border: '1px solid var(--color-border)',
          padding: '1rem',
          borderRadius: '8px'
        }}>
          <p>{`${label}: ${currencySymbol}${payload[0].value.toFixed(2)}`}</p>
        </div>
      );
    }
    return null;
  };

  return (
    <PriceTargetContainer>
      <SectionTitle>Price Target</SectionTitle>
      
      {/* --- All displayed values now use the dynamic currency symbol --- */}
      <PriceDisplay>{currencySymbol}{targetConsensus?.toFixed(2)}</PriceDisplay>
      <PriceChange isPositive={isPositive}>
          {isPositive ? '+' : ''}{currencySymbol}{change.toFixed(2)} ({isPositive ? '+' : ''}{changePercent.toFixed(2)}%)
      </PriceChange>
      <SummaryText>
        The analysts offering 1-year price forecasts have a max estimate of {currencySymbol}{targetHigh?.toFixed(2)} and a min estimate of {currencySymbol}{targetLow?.toFixed(2)}.
      </SummaryText>

      <ChartWrapper>
        <ResponsiveContainer>
          <LineChart data={chartData} margin={{ top: 20, right: 30, left: 0, bottom: 20 }}>
            <XAxis dataKey="name" stroke="var(--color-text-secondary)" tick={{ fill: 'var(--color-text-secondary)' }} />
            <YAxis 
                stroke="var(--color-text-secondary)" 
                domain={['dataMin - 20', 'dataMax + 20']}
                tick={{ fill: 'var(--color-text-secondary)' }}
                tickFormatter={(tick) => `${currencySymbol}${tick}`} // Add currency to the axis
            />
            <Tooltip content={<CustomTooltip />} />
            
            <Line type="monotone" dataKey="value" stroke="var(--color-primary)" strokeWidth={2} dot={{ r: 4 }} />

            {/* Reference lines now also include the dynamic currency symbol */}
            <ReferenceLine y={targetHigh} stroke="var(--color-success)" strokeDasharray="3 3">
                <Label value={`Max: ${currencySymbol}${targetHigh.toFixed(2)}`} position="right" fill="var(--color-success)" />
            </ReferenceLine>
            <ReferenceLine y={targetLow} stroke="var(--color-danger)" strokeDasharray="3 3">
                <Label value={`Min: ${currencySymbol}${targetLow.toFixed(2)}`} position="right" fill="var(--color-danger)" />
            </ReferenceLine>
            <ReferenceLine y={targetConsensus} stroke="var(--color-primary)" strokeDasharray="3 3">
                <Label value={`Avg: ${currencySymbol}${targetConsensus.toFixed(2)}`} position="right" fill="var(--color-primary)" />
            </ReferenceLine>
            <ReferenceLine y={currentPrice} stroke="#fff" strokeDasharray="1 1">
                <Label value={`Current: ${currencySymbol}${currentPrice.toFixed(2)}`} position="left" fill="#fff" />
            </ReferenceLine>
            
          </LineChart>
        </ResponsiveContainer>
      </ChartWrapper>
    </PriceTargetContainer>
  );
};

export default PriceTarget;
</file>

<file path="frontend/src/components/Fundamentals/DarvasScan.js">
import React from 'react';
import styled from 'styled-components';

// --- Styled Components ---

const ScanContainer = styled.div`
  /* Main container for the Darvas Scan section */
`;

const StatusValue = styled.span`
  font-size: 2rem;
  font-weight: 700;
  /* Dynamically sets the color based on the scan result */
  color: ${({ result }) => {
    if (result === 'Pass') return 'var(--color-success)';
    if (result === 'Fail') return 'var(--color-danger)';
    return 'var(--color-primary)';
  }};
`;

const MessageText = styled.p`
  font-size: 1rem;
  color: var(--color-text-secondary);
  line-height: 1.6;
  margin-top: 0.5rem;
`;

const BoxInfoGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1.5rem;
  margin-top: 1.5rem;
  padding-top: 1.5rem;
  border-top: 1px solid var(--color-border);
`;

const BoxInfoItem = styled.div`
  background-color: var(--color-background);
  padding: 1rem;
  border-radius: 8px;
`;

const BoxLabel = styled.div`
  font-size: 0.9rem;
  color: var(--color-text-secondary);
  margin-bottom: 0.5rem;
`;

const BoxValue = styled.div`
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--color-text-primary);
`;

// --- Intelligent Currency Helper Function ---
const getCurrencySymbol = (currencyCode) => {
    switch (currencyCode) {
        case 'INR':
            return '₹';
        case 'USD':
            return '$';
        case 'JPY':
            return '¥';
        // Add more currencies as needed
        default:
            return '$'; // Default to dollar if currency is unknown
    }
};

// --- The Final, Corrected React Component ---

// It now accepts the 'currency' prop from its parent, Fundamentals.js
const DarvasScan = ({ scanData, currency }) => {

  // If the data from the backend is missing, show an informative message.
  if (!scanData || !scanData.status) {
    return (
      <ScanContainer>
        <p>Darvas Scan data is not available for this stock.</p>
      </ScanContainer>
    );
  }

  const { status, message, box_top, box_bottom, result } = scanData;
  
  // Get the correct currency symbol to display.
  const currencySymbol = getCurrencySymbol(currency);

  return (
    <ScanContainer>
      <StatusValue result={result}>{status}</StatusValue>
      <MessageText>{message}</MessageText>

      {/* Only show the Box Top/Bottom info if a valid box has been identified by the backend. */}
      {box_top && box_bottom && (
        <BoxInfoGrid>
          <BoxInfoItem>
            <BoxLabel>Box Top (Resistance)</BoxLabel>
            {/* --- UPDATED: Use the dynamic currency symbol --- */}
            <BoxValue>{currencySymbol}{box_top.toFixed(2)}</BoxValue>
          </BoxInfoItem>
          <BoxInfoItem>
            <BoxLabel>Box Bottom (Support)</BoxLabel>
            {/* --- UPDATED: Use the dynamic currency symbol --- */}
            <BoxValue>{currencySymbol}{box_bottom.toFixed(2)}</BoxValue>
          </BoxInfoItem>
        </BoxInfoGrid>
      )}
    </ScanContainer>
  );
};

export default DarvasScan;
</file>

<file path="frontend/src/components/HomePage/ChartUploader.js">
import React, { useState, useCallback, useRef, useEffect } from 'react';
import styled, { keyframes } from 'styled-components';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

// --- Styled Components & Animations ---

const pulse = keyframes`
  0% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(88, 166, 255, 0.4);
  }
  70% {
    transform: scale(1.02);
    box-shadow: 0 0 10px 20px rgba(88, 166, 255, 0);
  }
  100% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(88, 166, 255, 0);
  }
`;

const fadeIn = keyframes`
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
`;

// --- HIGH END "GLASSMORPHISM" UI ---
const UploaderContainer = styled.div`
  width: 100%;
  max-width: 750px;
  margin-top: 3rem;
  padding: 3rem 2rem;
  
  /* Glassmorphism Background */
  background: linear-gradient(145deg, rgba(22, 27, 34, 0.6), rgba(13, 17, 23, 0.8));
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  
  /* Border and Shadow */
  border: 2px dashed ${({ isDragActive }) => (isDragActive ? 'var(--color-primary)' : 'rgba(88, 166, 255, 0.2)')};
  border-radius: 20px;
  box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
  
  text-align: center;
  cursor: pointer;
  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
  animation: ${fadeIn} 0.8s ease-out;

  &:hover {
    border-color: var(--color-primary);
    transform: translateY(-5px);
    box-shadow: 0 12px 40px 0 rgba(88, 166, 255, 0.15);
    background: linear-gradient(145deg, rgba(22, 27, 34, 0.8), rgba(13, 17, 23, 0.9));
  }
`;

const UploadText = styled.p`
  color: var(--color-text-secondary);
  font-size: 1.1rem;
  margin: 0;
  pointer-events: none; /* Ensures the click passes through to container */
`;

const HighlightText = styled.span`
  color: var(--color-primary);
  font-weight: 700;
  text-decoration: underline;
  text-underline-offset: 4px;
`;

const LoaderText = styled.p`
  color: var(--color-primary);
  font-size: 1.3rem;
  font-weight: 700;
  animation: ${pulse} 2s infinite;
  margin: 0;
`;

const ErrorText = styled.p`
  color: var(--color-danger);
  font-size: 1rem;
  font-weight: 500;
  margin-top: 1rem;
  background: rgba(248, 81, 73, 0.1);
  padding: 0.5rem 1rem;
  border-radius: 8px;
  display: inline-block;
  border: 1px solid rgba(248, 81, 73, 0.3);
`;

// --- The Final, Feature-Rich Component ---

const ChartUploader = () => {
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState('');
  const [isDragActive, setIsDragActive] = useState(false);
  const navigate = useNavigate();
  const fileInputRef = useRef(null);

  // --- CORE UPLOAD LOGIC ---
  const handleUpload = useCallback(async (file) => {
    if (!file) return;

    setIsUploading(true);
    setError('');

    const formData = new FormData();
    formData.append('chart_image', file);

    try {
      const response = await axios.post('/api/charts/analyze', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });
      
      const { identified_symbol, analysis_data } = response.data;

      if (!identified_symbol || identified_symbol === 'NOT_FOUND') {
        setError('AI could not identify a stock symbol. Please upload a clearer chart screenshot.');
        setIsUploading(false);
        return;
      }
      
      // Intelligent Navigation based on Symbol Type
      const isIndex = identified_symbol.includes('^');
      const encodedSymbol = encodeURIComponent(identified_symbol);

      if (isIndex) {
        navigate(`/index/${encodedSymbol}`, { state: { chartAnalysis: analysis_data } });
      } else {
        navigate(`/stock/${encodedSymbol}`, { state: { chartAnalysis: analysis_data } });
      }

    } catch (err) {
      console.error("Chart analysis failed:", err);
      setError('An error occurred during AI analysis. Please try again.');
      setIsUploading(false);
    }
  }, [navigate]);

  // --- CLIPBOARD PASTE LISTENER (Ctrl+V) ---
  useEffect(() => {
    const handlePaste = (e) => {
      const items = e.clipboardData.items;
      for (let i = 0; i < items.length; i++) {
        // Look for items that are images
        if (items[i].type.indexOf('image') !== -1) {
          const file = items[i].getAsFile();
          handleUpload(file);
          // We found an image, so we can stop looking
          break;
        }
      }
    };

    // Attach listener to the document
    document.addEventListener('paste', handlePaste);

    // Cleanup listener when component unmounts
    return () => document.removeEventListener('paste', handlePaste);
  }, [handleUpload]);

  // --- DRAG AND DROP HANDLERS ---
  const handleDrag = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === "dragenter" || e.type === "dragover") {
      setIsDragActive(true);
    } else if (e.type === "dragleave") {
      setIsDragActive(false);
    }
  }, []);

  const handleDrop = useCallback((e) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragActive(false);
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      handleUpload(e.dataTransfer.files[0]);
    }
  }, [handleUpload]);

  // --- CLICK HANDLERS ---
  const onFileChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      handleUpload(e.target.files[0]);
    }
  };

  const onContainerClick = () => {
    fileInputRef.current.click();
  };

  return (
    <div style={{ width: '100%', display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
      <input
        type="file"
        id="chart-upload-input"
        ref={fileInputRef}
        style={{ display: 'none' }}
        onChange={onFileChange}
        accept="image/png, image/jpeg, image/webp"
      />
      
      <UploaderContainer
        onClick={onContainerClick}
        onDragEnter={handleDrag}
        onDragLeave={handleDrag}
        onDragOver={handleDrag}
        onDrop={handleDrop}
        isDragActive={isDragActive}
      >
        {isUploading ? (
          <LoaderText>Analyzing Chart Pattern & Sentiment...</LoaderText>
        ) : (
          <UploadText>
            Drag & Drop, <strong>Paste (Ctrl+V)</strong>, or <HighlightText>Click to Upload</HighlightText>
          </UploadText>
        )}
      </UploaderContainer>
      
      {error && <ErrorText>{error}</ErrorText>}
    </div>
  );
};

export default ChartUploader;
</file>

<file path="frontend/src/components/Peers/PeersComparison.js">
import React, { useState, useEffect, useMemo } from 'react';
import styled, { keyframes } from 'styled-components';
import axios from 'axios';
import Card from '../common/Card';

// --- Styled Components ---

const fadeIn = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;

const Loader = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  height: 200px;
  color: var(--color-primary);
  animation: ${fadeIn} 0.5s ease-in;
`;

const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto; /* Allows horizontal scrolling on small screens */
  animation: ${fadeIn} 0.5s ease-in;
`;

const StyledTable = styled.table`
  width: 100%;
  border-collapse: collapse;
  text-align: right;
`;

const TableHeader = styled.th`
  padding: 1rem;
  color: var(--color-text-secondary);
  font-weight: 500;
  font-size: 0.9rem;
  border-bottom: 1px solid var(--color-border);
  cursor: pointer;
  transition: color 0.2s ease;
  white-space: nowrap;

  &:first-child {
    text-align: left;
  }

  &:hover {
    color: var(--color-text-primary);
  }
`;

const TableRow = styled.tr`
  /* Highlight the row for the main symbol being analyzed */
background-color: ${({ $isMainSymbol }) => $isMainSymbol ? 'rgba(88, 166, 255, 0.1)' : 'transparent'};  
  &:not(:last-child) {
    border-bottom: 1px solid var(--color-border);
  }
`;

const TableCell = styled.td`
  padding: 1rem;
  font-size: 0.95rem;
  font-family: 'Roboto Mono', monospace; /* Use a monospaced font for numerical data */

  &:first-child {
    font-weight: 600;
    color: var(--color-text-primary);
    text-align: left;
    font-family: 'Inter', sans-serif; /* Use the standard font for the symbol name */
  }
`;

// --- Helper Functions to Format Data ---

const formatMarketCap = (num) => {
  if (num === null || num === undefined || isNaN(num)) return 'N/A';
  if (Math.abs(num) >= 1e12) return `${(num / 1e12).toFixed(2)}T`;
  if (Math.abs(num) >= 1e9) return `${(num / 1e9).toFixed(2)}B`;
  if (Math.abs(num) >= 1e6) return `${(num / 1e6).toFixed(2)}M`;
  return num.toLocaleString();
};

const formatPercent = (num) => {
  if (num === null || num === undefined || isNaN(num)) return 'N/A';
  return `${(num * 100).toFixed(2)}%`;
};

const formatNumber = (num) => {
  if (num === null || num === undefined || isNaN(num)) return 'N/A';
  return num.toFixed(2);
};

// --- The Definitive, Robust React Component ---

const PeersComparison = ({ symbol }) => {
  const [peersData, setPeersData] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [sortConfig, setSortConfig] = useState({ key: 'marketCap', direction: 'descending' });

  useEffect(() => {
    const fetchPeersData = async () => {
      if (!symbol) {
        setIsLoading(false);
        return;
      }
      setIsLoading(true);
      try {
        const response = await axios.get(`/api/stocks/${symbol}/peers`);
        setPeersData(response.data);
      } catch (error) {
        console.error("Failed to fetch peers data:", error);
        setPeersData([]);
      } finally {
        setIsLoading(false);
      }
    };
    // Add a small delay to this lazy-loaded fetch.
    const timer = setTimeout(fetchPeersData, 300);
    return () => clearTimeout(timer);
  }, [symbol]);

  // This is the logic for sorting the table's columns.
  const sortedPeers = useMemo(() => {
    let sortableItems = [...peersData];
    if (sortConfig !== null) {
      sortableItems.sort((a, b) => {
        // This robust logic checks for both FMP's key and Yahoo's key.
        const aValue = a[sortConfig.key] || a[sortConfig.key.replace('TTM', '')] || 0;
        const bValue = b[sortConfig.key] || b[sortConfig.key.replace('TTM', '')] || 0;
        
        if (aValue < bValue) {
          return sortConfig.direction === 'ascending' ? -1 : 1;
        }
        if (aValue > bValue) {
          return sortConfig.direction === 'ascending' ? 1 : -1;
        }
        return 0;
      });
    }
    return sortableItems;
  }, [peersData, sortConfig]);

  const requestSort = (key) => {
    let direction = 'ascending';
    if (sortConfig.key === key && sortConfig.direction === 'ascending') {
      direction = 'descending';
    }
    setSortConfig({ key, direction });
  };

  // --- Render Logic ---

  if (isLoading) {
    return (
      <Card title="Peers Comparison">
        <Loader>Finding and analyzing peers with AI...</Loader>
      </Card>
    );
  }

  if (!peersData || peersData.length <= 1) {
    return (
      <Card title="Peers Comparison">
        <p>Peer comparison data is not available for this stock.</p>
      </Card>
    );
  }

  return (
    <Card title="Peers Comparison">
      <TableContainer>
        <StyledTable>
          <thead>
            <tr>
              <TableHeader onClick={() => requestSort('symbol')}>Symbol</TableHeader>
              <TableHeader onClick={() => requestSort('marketCap')}>Market Cap</TableHeader>
              <TableHeader onClick={() => requestSort('peRatioTTM')}>P/E Ratio (TTM)</TableHeader>
              <TableHeader onClick={() => requestSort('revenueGrowth')}>Revenue Growth</TableHeader>
              <TableHeader onClick={() => requestSort('grossMargins')}>Gross Margin</TableHeader>
            </tr>
          </thead>
          <tbody>
            {sortedPeers.map(peer => (
<TableRow key={peer.symbol} $isMainSymbol={peer.symbol === symbol}>
                <TableCell>{peer.symbol}</TableCell>
                {/* This is the ultimate robust display logic, checking for both FMP's key and Yahoo's key for every cell */}
                <TableCell>{formatMarketCap(peer.marketCapTTM || peer.marketCap)}</TableCell>
                <TableCell>{formatNumber(peer.peRatioTTM)}</TableCell>
                <TableCell>{formatPercent(peer.revenueGrowthTTM || peer.revenueGrowth)}</TableCell>
                <TableCell>{formatPercent(peer.grossProfitMarginTTM || peer.grossMargins)}</TableCell>
              </TableRow>
            ))}
          </tbody>
        </StyledTable>
      </TableContainer>
    </Card>
  );
};

export default PeersComparison;
</file>

<file path="frontend/src/components/StockDetailPage/ChartAnalysis.js">
import React, { useState, useMemo, useEffect } from 'react';
import styled, { keyframes } from 'styled-components';
import { useParams } from 'react-router-dom';
import axios from 'axios';
import Card from '../common/Card';
// We import beautiful, professional icons to enhance our UI
import { 
  FaArrowUp, FaArrowDown, FaExchangeAlt, FaGem, FaExclamationTriangle, 
  FaShieldAlt, FaBullseye, FaChartLine, FaMoneyBillWave, FaCrosshairs, FaStopCircle, FaClock
} from 'react-icons/fa';

// --- Styled Components & Animations ---

const fadeIn = keyframes`
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
`;

const pulseAnimation = keyframes`
  0% { opacity: 0.6; }
  50% { opacity: 1; }
  100% { opacity: 0.6; }
`;

const AnalysisGrid = styled.div`
  display: grid;
  gap: 1.5rem;
  animation: ${fadeIn} 0.5s ease-out;
  opacity: ${({ isUpdating }) => (isUpdating ? 0.5 : 1)};
  transition: opacity 0.3s ease;
  pointer-events: ${({ isUpdating }) => (isUpdating ? 'none' : 'auto')};
`;

// --- TIMEFRAME SELECTOR STYLES ---
const TimeframeBar = styled.div`
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-bottom: 2rem;
  padding: 0.5rem;
  background-color: var(--color-background);
  border-radius: 12px;
  border: 1px solid var(--color-border);
  width: fit-content;
  margin-left: auto;
  margin-right: auto;
`;

const TimeframeButton = styled.button`
  background: ${({ active }) => (active ? 'var(--color-primary)' : 'transparent')};
  color: ${({ active }) => (active ? '#ffffff' : 'var(--color-text-secondary)')};
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 8px;
  font-weight: 600;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    color: ${({ active }) => (active ? '#ffffff' : 'var(--color-text-primary)')};
    background: ${({ active }) => (active ? 'var(--color-primary)' : 'rgba(255,255,255,0.05)')};
  }
`;

// --- VERDICT CARD STYLES ---
const VerdictCard = styled(Card)`
  text-align: center;
  border-left: 4px solid ${({ color }) => color};
  box-shadow: 0 4px 15px ${({ color }) => color}22;
`;

const TrendDisplay = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.75rem;
  font-size: 1.8rem;
  font-weight: 700;
  margin-bottom: 1rem;
  color: ${({ color }) => color};
`;

const ContentText = styled.p`
  font-size: 1rem;
  color: var(--color-text-secondary);
  line-height: 1.7;
`;

const ConclusionText = styled(ContentText)`
  font-size: 1.1rem;
  font-style: italic;
  color: var(--color-text-primary);
  max-width: 85%;
  margin: 0 auto;
`;

// --- TRADE TICKET STYLES ---
const TradeTicket = styled.div`
  background: linear-gradient(135deg, rgba(22, 27, 34, 0.95), rgba(30, 41, 59, 0.95));
  border: 1px solid ${({ action }) => (action === 'BUY' ? 'var(--color-success)' : action === 'SELL' ? 'var(--color-danger)' : 'var(--color-border)')};
  border-radius: 16px;
  padding: 2rem;
  position: relative;
  overflow: hidden;
  box-shadow: 0 10px 30px rgba(0,0,0,0.2);
  
  &::before {
    content: '${({ action }) => action}';
    position: absolute;
    top: -10px;
    right: -10px;
    font-size: 6rem;
    font-weight: 900;
    opacity: 0.05;
    color: ${({ action }) => (action === 'BUY' ? 'var(--color-success)' : action === 'SELL' ? 'var(--color-danger)' : '#FFF')};
    pointer-events: none;
  }
`;

const TicketHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 2rem;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  padding-bottom: 1rem;
`;

const ActionBadge = styled.span`
  background-color: ${({ action }) => (action === 'BUY' ? 'rgba(16, 185, 129, 0.2)' : action === 'SELL' ? 'rgba(239, 68, 68, 0.2)' : 'rgba(100, 116, 139, 0.2)')};
  color: ${({ action }) => (action === 'BUY' ? 'var(--color-success)' : action === 'SELL' ? 'var(--color-danger)' : '#94A3B8')};
  border: 1px solid ${({ action }) => (action === 'BUY' ? 'var(--color-success)' : action === 'SELL' ? 'var(--color-danger)' : '#94A3B8')};
  padding: 0.5rem 1.5rem;
  border-radius: 50px;
  font-weight: 800;
  font-size: 1.2rem;
  letter-spacing: 1px;
  box-shadow: 0 0 15px ${({ action }) => (action === 'BUY' ? 'rgba(16, 185, 129, 0.2)' : action === 'SELL' ? 'rgba(239, 68, 68, 0.2)' : 'transparent')};
`;

const TradeMetricGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
`;

const TradeMetric = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
`;

const MetricLabel = styled.span`
  font-size: 0.85rem;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: var(--color-text-secondary);
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  gap: 5px;
`;

const MetricValue = styled.span`
  font-size: 1.3rem;
  font-weight: 700;
  color: ${({ color }) => color || 'var(--color-text-primary)'};
`;

const RationaleBox = styled.div`
  background: rgba(255,255,255,0.03);
  padding: 1rem;
  border-radius: 8px;
  border-left: 3px solid var(--color-primary);
`;

const DetailsGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1.5rem;
  @media (max-width: 992px) {
    grid-template-columns: 1fr;
  }
`;

const InfoCard = styled(Card)`
  background-color: var(--color-background);
`;

const SectionTitle = styled.h4`
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--color-text-primary);
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
`;

const InfoList = styled.ul`
  list-style-type: none;
  padding-left: 0;
`;

const InfoListItem = styled.li`
  margin-bottom: 1rem;
  color: var(--color-text-secondary);
  line-height: 1.6;
  display: flex;
  align-items: flex-start;
  gap: 0.75rem;

  & > svg {
    flex-shrink: 0;
    margin-top: 5px;
    color: var(--color-primary);
  }
`;

const LoadingOverlay = styled.div`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(13, 17, 23, 0.7);
  display: flex;
  flex-direction: column; /* Stack icon and text */
  align-items: center;
  justify-content: center;
  z-index: 10;
  border-radius: 12px;
  backdrop-filter: blur(2px);
  animation: ${fadeIn} 0.3s ease;
`;

const PulseLoader = styled.div`
  color: var(--color-primary);
  font-size: 1.2rem;
  font-weight: 600;
  animation: ${pulseAnimation} 1.5s infinite;
  display: flex;
  align-items: center;
  gap: 10px;
`;



// --- The Masterpiece Component ---

const ChartAnalysis = ({ analysisData: initialAnalysisData }) => {
  const { symbol } = useParams(); // Use React Router to get the current symbol
  
  // --- CACHING STATE MANAGEMENT ---
  // We initialize the cache with the original image analysis.
  // 'analysisCache' is an object where keys are timeframes ('Image', '5m', etc.) and values are the text.
  const [analysisCache, setAnalysisCache] = useState({ 'Image': initialAnalysisData });

  const [timeframeAnalysis, setTimeframeAnalysis] = useState(null); 
  
  const [activeTimeframe, setActiveTimeframe] = useState('Image');
  const [isUpdating, setIsUpdating] = useState(false);

  // If the user navigates to a NEW stock, we need to reset the cache.
  // We check if the 'initialAnalysisData' prop has changed.
  useEffect(() => {
    setAnalysisCache({ 'Image': initialAnalysisData });
    setActiveTimeframe('Image');
  }, [initialAnalysisData, symbol]);

  // Define available timeframes
  const timeframes = ['5m', '15m', '1h', '4h', '1d'];

  // Handle Timeframe Switch
  const handleTimeframeChange = async (tf) => {
    if (activeTimeframe === tf) return; // Don't do anything if clicking the same button
    
    setActiveTimeframe(tf);
    
    // 1. CHECK CACHE: Do we already have data for this timeframe?
    if (analysisCache[tf]) {
        // If yes, load it instantly from memory! No API call needed.
        return; 
    }
    
    // 2. FETCH: If not in cache, show loader and fetch from API
    setIsUpdating(true);
    
    try {
      const response = await axios.post(`/api/stocks/${symbol}/timeframe-analysis`, {
        timeframe: tf
      });
      
      const newData = response.data.analysis;
      
      // 3. SAVE TO CACHE: Store the result so we don't have to load it again
      setAnalysisCache(prevCache => ({
          ...prevCache,
          [tf]: newData
      }));
      setTimeframeAnalysis(newData);
      
    } catch (error) {
      console.error("Timeframe analysis failed:", error);
    } finally {
      setIsUpdating(false);
    }
  };
  const handleResetToImage = () => {
      setActiveTimeframe('Image');
      setTimeframeAnalysis(null); // Clear the timeframe data to show the original image data
  };

  // Determine what text to display based on the active timeframe
  const currentAnalysis = analysisCache[activeTimeframe];

  // --- The Parser: Extracts data for both the Verdict and the Trade Ticket ---
  const parsedAnalysis = useMemo(() => {
    if (!currentAnalysis || typeof currentAnalysis !== 'string') {
      return null;
    }
    const sections = {};
    const keywords = [
        'TREND:', 'TIMEFRAME:', 'PATTERNS:', 'LEVELS:', 'VOLUME:', 'INDICATORS:', 'CONCLUSION:', 
        'ACTION:', 'ENTRY_ZONE:', 'STOP_LOSS:', 'TARGET_1:', 'TARGET_2:', 'RISK_REWARD:', 'CONFIDENCE:', 'RATIONALE:'
    ];
    
    let currentKey = null;
    let contentBuffer = [];

    currentAnalysis.split('\n').forEach(line => {
      const foundKeyword = keywords.find(kw => line.startsWith(kw));
      if (foundKeyword) {
        if (currentKey) {
          sections[currentKey] = contentBuffer.join('\n').trim();
        }
        currentKey = foundKeyword.replace(':', '').trim();
        contentBuffer = [line.replace(foundKeyword, '').trim()];
      } else if (currentKey) {
        contentBuffer.push(line.trim());
      }
    });
    if (currentKey) {
      sections[currentKey] = contentBuffer.join('\n').trim();
    }
    return sections;
  }, [currentAnalysis]); // Rerun parser when currentAnalysis text changes

  const getTrendInfo = () => {
    const trend = parsedAnalysis?.TREND?.toLowerCase() || '';
    if (trend.includes('uptrend')) return { Icon: FaArrowUp, color: 'var(--color-success)', text: 'Primary Uptrend' };
    if (trend.includes('downtrend')) return { Icon: FaArrowDown, color: 'var(--color-danger)', text: 'Primary Downtrend' };
    return { Icon: FaExchangeAlt, color: 'var(--color-text-secondary)', text: 'Sideways / Consolidation' };
  };

  if (!parsedAnalysis) {
    return (
      <Card>
        <p>AI Chart Analysis data is not available.</p>
      </Card>
    );
  }

  const { Icon: TrendIcon, color: trendColor, text: trendText } = getTrendInfo();
  const action = parsedAnalysis.ACTION ? parsedAnalysis.ACTION.toUpperCase() : 'WAIT';

  return (
    <div style={{ position: 'relative' }}>
      {/* --- TIMEFRAME SELECTOR --- */}
      <TimeframeBar>
        <TimeframeButton 
            active={activeTimeframe === 'Image'} 
            onClick={() => handleTimeframeChange('Image')}
        >
            <FaGem style={{marginRight:'5px'}}/> Original Image
        </TimeframeButton>
        {timeframes.map(tf => (
            <TimeframeButton 
                key={tf} 
                active={activeTimeframe === tf} 
                onClick={() => handleTimeframeChange(tf)}
            >
                {tf.toUpperCase()}
            </TimeframeButton>
        ))}
      </TimeframeBar>

      <AnalysisGrid isUpdating={isUpdating}>
        {/* --- 1. VERDICT CARD --- */}
        <VerdictCard color={trendColor}>
          <TrendDisplay color={trendColor}>
            <TrendIcon />
            {trendText}
          </TrendDisplay>
          <ConclusionText>
            "{parsedAnalysis.CONCLUSION || 'No conclusive summary available.'}"
          </ConclusionText>
        </VerdictCard>

        {/* --- 2. TRADE TICKET --- */}
        {parsedAnalysis.ENTRY_ZONE && (
            <TradeTicket action={action}>
              <TicketHeader>
                  <div>
                      <div style={{fontSize: '0.8rem', color: 'var(--color-text-secondary)', marginBottom: '5px', letterSpacing: '1px'}}>STRATEGY SIGNAL</div>
                      <ActionBadge action={action}>{action}</ActionBadge>
                  </div>
                  <div style={{textAlign: 'right'}}>
                      <div style={{fontSize: '0.8rem', color: 'var(--color-text-secondary)', marginBottom: '5px', letterSpacing: '1px'}}>AI CONFIDENCE</div>
                      <div style={{fontSize: '1.2rem', fontWeight: 'bold', color: 'var(--color-text-primary)'}}>{parsedAnalysis.CONFIDENCE}</div>
                  </div>
              </TicketHeader>

              <TradeMetricGrid>
                  <TradeMetric>
                      <MetricLabel><FaCrosshairs /> ENTRY ZONE</MetricLabel>
                      <MetricValue color="#60A5FA">{parsedAnalysis.ENTRY_ZONE}</MetricValue>
                  </TradeMetric>
                  <TradeMetric>
                      <MetricLabel><FaStopCircle /> STOP LOSS</MetricLabel>
                      <MetricValue color="#F87171">{parsedAnalysis.STOP_LOSS}</MetricValue>
                  </TradeMetric>
                  <TradeMetric>
                      <MetricLabel><FaMoneyBillWave /> TARGET 1</MetricLabel>
                      <MetricValue color="#34D399">{parsedAnalysis.TARGET_1}</MetricValue>
                  </TradeMetric>
                  <TradeMetric>
                      <MetricLabel><FaChartLine /> R/R RATIO</MetricLabel>
                      <MetricValue color="#FBBF24">{parsedAnalysis.RISK_REWARD}</MetricValue>
                  </TradeMetric>
              </TradeMetricGrid>

              <RationaleBox>
                  <strong style={{color: 'var(--color-primary)', display: 'block', marginBottom: '0.5rem'}}>Trade Rationale:</strong>
                  <span style={{color: 'var(--color-text-secondary)', lineHeight: '1.6'}}>{parsedAnalysis.RATIONALE}</span>
              </RationaleBox>
            </TradeTicket>
        )}
        
        {/* --- 3. DETAILS GRID --- */}
        <DetailsGrid>
          <InfoCard>
            <SectionTitle><FaGem /> Key Patterns</SectionTitle>
            <InfoList>
              {parsedAnalysis.PATTERNS?.split('\n').map((item, index) => (
                <InfoListItem key={index}><FaChartLine /> {item}</InfoListItem>
              ))}
            </InfoList>
          </InfoCard>

          <InfoCard>
            <SectionTitle><FaExclamationTriangle /> Volume & Indicators</SectionTitle>
            <InfoList>
              <InfoListItem><strong>Volume:</strong> {parsedAnalysis.VOLUME}</InfoListItem>
              <InfoListItem><strong>Indicators:</strong> {parsedAnalysis.INDICATORS}</InfoListItem>
            </InfoList>
          </InfoCard>
        </DetailsGrid>

        <InfoCard>
          <SectionTitle>Price Levels</SectionTitle>
          <DetailsGrid>
              <div>
                  <SectionTitle style={{fontSize: '1rem', color: '#34D399'}}><FaShieldAlt /> Support</SectionTitle>
                  <ContentText>{parsedAnalysis.LEVELS}</ContentText>
              </div>
              <div>
                  <SectionTitle style={{fontSize: '1rem', color: '#F87171'}}><FaBullseye /> Resistance</SectionTitle>
                   <ContentText>{parsedAnalysis.LEVELS}</ContentText>
              </div>
          </DetailsGrid>
        </InfoCard>
      </AnalysisGrid>

      {/* --- LOADING OVERLAY --- */}
      {isUpdating && (
          <LoadingOverlay>
              <PulseLoader><FaClock /> Analyzing New Timeframe...</PulseLoader>
          </LoadingOverlay>
      )}
    </div>
  );
};

export default ChartAnalysis;
</file>

<file path="frontend/src/components/Technicals/MovingAverages.js">
import React from 'react';
import styled from 'styled-components';

// --- Styled Components ---

const TableContainer = styled.div`
  width: 100%;
  max-width: 300px; /* Constrain width for a compact, clean look */
  margin-left: auto; /* Push the table to the right within its grid container */
`;

const StyledTable = styled.table`
  width: 100%;
  border-collapse: collapse;
`;

const TableHeader = styled.th`
  padding: 10px;
  color: var(--color-text-secondary);
  font-weight: 500;
  font-size: 0.9rem;
  text-align: left;
  border-bottom: 1px solid var(--color-border);
`;

const TableCell = styled.td`
  padding: 10px;
  font-size: 0.95rem;

  /* Style the period (e.g., "5 Days") cell */
  &:first-child {
    color: var(--color-text-secondary);
  }

  /* Style the calculated value cell */
  &:last-child {
    font-weight: 600;
    color: var(--color-text-primary);
    text-align: right;
    font-family: 'Roboto Mono', monospace; /* Use a monospaced font for numbers */
  }
`;

const TableRow = styled.tr`
  border-bottom: 1px solid var(--color-border);

  &:last-child {
    border-bottom: none; /* Remove the border for the last row */
  }
`;

// --- The New, Dynamic React Component ---

// The component now accepts 'maData' as a prop from its parent.
const MovingAverages = ({ maData }) => {
  // If the data is missing or empty, we show an informative message.
  if (!maData || Object.keys(maData).length === 0) {
    return (
      <TableContainer>
        <p>Moving average data is not available.</p>
      </TableContainer>
    );
  }

  // We create a structured array to ensure the rows are always in the correct order.
  const ma_periods = [
    { period: '5 Days', key: '5' },
    { period: '10 Days', key: '10' },
    { period: '20 Days', key: '20' },
    { period: '50 Days', key: '50' },
    { period: '100 Days', key: '100' },
    { period: '200 Days', key: '200' },
  ];

  return (
    <TableContainer>
      <StyledTable>
        <thead>
          <tr>
            <TableHeader>Period (SMA)</TableHeader>
            <TableHeader style={{ textAlign: 'right' }}>Value</TableHeader>
          </tr>
        </thead>
        <tbody>
          {ma_periods.map(item => {
            const value = maData[item.key];
            return (
              <TableRow key={item.period}>
                <TableCell>{item.period}</TableCell>
                {/* We check if the value is a valid number before displaying */}
                <TableCell>{typeof value === 'number' ? value.toFixed(2) : 'N/A'}</TableCell>
              </TableRow>
            );
          })}
        </tbody>
      </StyledTable>
    </TableContainer>
  );
};

export default MovingAverages;
</file>

<file path="frontend/src/components/Technicals/PivotLevels.js">
import React from 'react';
import styled from 'styled-components';

// --- Styled Components ---

const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto; /* Allows horizontal scrolling on small screens if needed */
`;

const StyledTable = styled.table`
  width: 100%;
  border-collapse: collapse;
  text-align: center;
`;

const TableHeader = styled.th`
  padding: 12px;
  color: var(--color-text-secondary);
  font-weight: 500;
  font-size: 0.9rem;
  border-bottom: 1px solid var(--color-border);
  white-space: nowrap; /* Prevents headers from wrapping */
`;

const TableCell = styled.td`
  padding: 12px;
  font-size: 0.95rem;
  font-family: 'Roboto Mono', monospace; /* Use a monospaced font for numbers */
  border-bottom: 1px solid var(--color-border);

  /* Style the 'Type' column differently */
  &:first-child {
    font-weight: 600;
    color: var(--color-text-primary);
    text-align: left;
    font-family: 'Inter', sans-serif;
  }
`;

const TableRow = styled.tr`
  /* A subtle hover effect for better user experience */
  &:hover {
    background-color: rgba(48, 54, 61, 0.5);
  }

  /* Remove bottom border for the very last row */
  &:last-child > td {
      border-bottom: none;
  }
`;

// --- The New, Dynamic React Component ---

// The component now accepts 'pivotData' as a prop from its parent.
const PivotLevels = ({ pivotData }) => {
  // If the data is missing or empty, we show an informative message.
  if (!pivotData || Object.keys(pivotData).length === 0) {
    return (
      <TableContainer>
        <p>Pivot point data is not available.</p>
      </TableContainer>
    );
  }

  // We dynamically create our rows from the keys in the 'pivotData' object
  // that our new backend provides (e.g., "classic", "fibonacci", "camarilla").
  const pivotRows = [
    { type: 'Classic', data: pivotData.classic },
    { type: 'Fibonacci', data: pivotData.fibonacci },
    { type: 'Camarilla', data: pivotData.camarilla },
  ];

  return (
    <TableContainer>
      <StyledTable>
        <thead>
          <tr>
            <TableHeader>Type</TableHeader>
            <TableHeader>R3</TableHeader>
            <TableHeader>R2</TableHeader>
            <TableHeader>R1</TableHeader>
            <TableHeader>Pivot Point (PP)</TableHeader>
            <TableHeader>S1</TableHeader>
            <TableHeader>S2</TableHeader>
            <TableHeader>S3</TableHeader>
          </tr>
        </thead>
        <tbody>
          {pivotRows.map(row => {
            const { type, data } = row;
            // A safety check: Don't render a row if its specific data is missing
            if (!data) return null;
            
            return (
              <TableRow key={type}>
                <TableCell>{type}</TableCell>
                {/* We use optional chaining (?.) and the nullish coalescing operator (??) 
                    for maximum safety. This prevents crashes if a value is null or undefined. */}
                <TableCell>{data.r3?.toFixed(2) ?? 'N/A'}</TableCell>
                <TableCell>{data.r2?.toFixed(2) ?? 'N/A'}</TableCell>
                <TableCell>{data.r1?.toFixed(2) ?? 'N/A'}</TableCell>
                <TableCell>{data.pp?.toFixed(2) ?? 'N/A'}</TableCell>
                <TableCell>{data.s1?.toFixed(2) ?? 'N/A'}</TableCell>
                <TableCell>{data.s2?.toFixed(2) ?? 'N/A'}</TableCell>
                <TableCell>{data.s3?.toFixed(2) ?? 'N/A'}</TableCell>
              </TableRow>
            );
          })}
        </tbody>
      </StyledTable>
    </TableContainer>
  );
};

export default PivotLevels;
</file>

<file path="frontend/src/components/Technicals/TechnicalIndicatorsTable.js">
import React from 'react';
import styled, { keyframes } from 'styled-components';

// --- Styled Components & Animations ---

const fadeInRow = keyframes`
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;

const TableContainer = styled.div`
  width: 100%;
  margin-top: 2rem;
  padding-top: 1.5rem;
  border-top: 1px solid var(--color-border);
`;

const StyledTable = styled.table`
  width: 100%;
  border-collapse: collapse;
`;

const TableHeader = styled.th`
  padding: 12px;
  color: var(--color-text-secondary);
  font-weight: 500;
  font-size: 0.9rem;
  text-align: left;
  
  &:nth-child(2) {
    text-align: right;
  }
  &:last-child {
    text-align: right;
  }
`;

const TableRow = styled.tr`
  opacity: 0; /* Start hidden for animation */
  animation: ${fadeInRow} 0.5s ease-out forwards;
  /* Stagger the animation for each row for a beautiful effect */
  animation-delay: ${({ delay }) => delay * 0.05}s;
  
  &:not(:last-child) {
    border-bottom: 1px solid var(--color-border);
  }
`;

const TableCell = styled.td`
  padding: 14px 12px;
  font-size: 0.95rem;
  font-weight: 500;
  white-space: pre-wrap; /* Allows the multiline content for Bollinger Bands */

  &:first-child {
    font-weight: 600;
    color: var(--color-text-primary);
  }
  
  &:nth-child(2) {
    text-align: right;
    font-family: 'Roboto Mono', monospace;
  }

  &:last-child {
    text-align: right;
    font-weight: 700;
  }
`;

const Indication = styled.span`
  color: ${({ type }) => {
    switch (type) {
      case 'Bullish':
      case 'Oversold':
        return 'var(--color-success)';
      case 'Bearish':
      case 'Overbought':
        return 'var(--color-danger)';
      default:
        return 'var(--color-text-secondary)';
    }
  }};
`;

// --- The Corrected React Component ---

const TechnicalIndicatorsTable = ({ indicators }) => {
  if (!indicators || Object.keys(indicators).length === 0) {
    return (
      <TableContainer>
        <p>Technical indicator data is not available.</p>
      </TableContainer>
    );
  }

  // --- THIS IS THE CRITICAL FIX FOR BOLLINGER BANDS ---
  // We now safely access the nested 'bollingerBands' object, providing an empty object as a fallback.
  const bb = indicators.bollingerBands || {};

  const indicatorList = [
    { name: 'RSI(14)', level: indicators.rsi, indication: indicators.rsi < 30 ? 'Oversold' : indicators.rsi > 70 ? 'Overbought' : (indicators.rsi < 50 ? 'Bearish' : 'Bullish') },
    { name: 'MACD(12,26,9)', level: indicators.macd, indication: indicators.macd > indicators.macdsignal ? 'Bullish' : 'Bearish' },
    { name: 'Stochastic(14,3)', level: indicators.stochasticsk, indication: indicators.stochasticsk < 20 ? 'Oversold' : indicators.stochasticsk > 80 ? 'Overbought' : 'Neutral' },
    { name: 'ADX(14)', level: indicators.adx, indication: indicators.adx > 25 ? 'Strong Trend' : 'Weak Trend' },
    { name: 'Williams %R(14)', level: indicators.williamsr, indication: indicators.williamsr < -80 ? 'Oversold' : indicators.williamsr > -20 ? 'Overbought' : 'Neutral' },
    { name: 'ATR(14)', level: indicators.atr, indication: 'Volatility' },
    // We now correctly and safely access the properties from our 'bb' object.
    { name: 'Bollinger Band(20,2)', level: `UB: ${bb.upperBand?.toFixed(2) ?? 'N/A'}\nLB: ${bb.lowerBand?.toFixed(2) ?? 'N/A'}\nSMA: ${bb.middleBand?.toFixed(2) ?? 'N/A'}`, indication: '--' },
  ];
  
  return (
    <TableContainer>
      <StyledTable>
        <thead>
          <tr>
            <TableHeader>Indicator</TableHeader>
            <TableHeader>Level</TableHeader>
            <TableHeader>Indication</TableHeader>
          </tr>
        </thead>
        <tbody>
          {indicatorList.map((item, index) => (
            <TableRow key={item.name} delay={index}>
              <TableCell>{item.name}</TableCell>
              <TableCell>{typeof item.level === 'number' ? item.level.toFixed(2) : item.level}</TableCell>
              <TableCell>
                <Indication type={item.indication}>
                  {item.indication}
                </Indication>
              </TableCell>
            </TableRow>
          ))}
        </tbody>
      </StyledTable>
    </TableContainer>
  );
};

export default TechnicalIndicatorsTable;
</file>

<file path="frontend/src/styles/GlobalStyles.js">
import { createGlobalStyle } from 'styled-components';

export const GlobalStyles = createGlobalStyle`
  /* CSS Variables for our color palette */
  :root {
    --color-background: #0D1117;       /* Deep, dark blue-grey (like GitHub) */
    --color-primary: #58A6FF;          /* A vibrant, accessible blue */
    --color-secondary: #161B22;       /* Slightly lighter background for cards/containers */
    --color-text-primary: #C9D1D9;     /* Light grey for primary text */
    --color-text-secondary: #8B949E;   /* Darker grey for secondary text/labels */
    --color-border: #30363D;          /* Border color */
    --color-success: #3FB950;          /* Green for positive changes */
    --color-danger: #F85149;           /* Red for negative changes */
    --font-family-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  }

  /* Resetting default styles */
  *,
  *::before,
  *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  html {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    /* Mobile First: Slightly smaller base size */
    font-size: 14px; 
    
    /* Tablet & Desktop: Scale up */
    @media (min-width: 768px) {
      font-size: 16px;
    }
  }

  body {
    background-color: var(--color-background);
    color: var(--color-text-primary);
    font-family: var(--font-family-sans);
    line-height: 1.5;
  }

  h1, h2, h3, h4, h5, h6 {
    color: var(--color-text-primary);
    font-weight: 600;
  }

  a {
    color: var(--color-primary);
    text-decoration: none;
  }

  /* Custom scrollbar for a more modern look */
  ::-webkit-scrollbar {
    width: 8px;
  }
  ::-webkit-scrollbar-track {
    background: var(--color-secondary);
  }
  ::-webkit-scrollbar-thumb {
    background: #4A5568; /* A neutral grey */
    border-radius: 4px;
  }
  ::-webkit-scrollbar-thumb:hover {
    background: #718096;
  }
`;
</file>

<file path="backend/app/services/fundamental_service.py">
import pandas as pd

def calculate_piotroski_f_score(income_statements, balance_sheets, cash_flow_statements):
    """
    Calculates the Piotroski F-Score based on 9 criteria using historical financial data.
    """
    score = 0
    criteria_met = []

    # Ensure we have at least two years of data to compare for the calculations.
    if len(income_statements) < 2 or len(balance_sheets) < 2 or len(cash_flow_statements) < 2:
        return {"score": 0, "criteria": ["Not enough historical data."]}

    try:
        # Use pandas DataFrames for easier data manipulation and access.
        income_df = pd.DataFrame(income_statements).set_index('date').sort_index()
        balance_df = pd.DataFrame(balance_sheets).set_index('date').sort_index()
        cash_flow_df = pd.DataFrame(cash_flow_statements).set_index('date').sort_index()

        # Get the dates for the current and previous year for comparison.
        cy = income_df.index[-1] # Current Year
        py = income_df.index[-2] # Previous Year

        # --- Piotroski F-Score Criteria (9 points) ---

        # 1. Net Income (Profitability)
        net_income = income_df.loc[cy, 'netIncome']
        if net_income > 0:
            score += 1
            criteria_met.append("Positive Net Income")

        # 2. Operating Cash Flow (Profitability)
        op_cash_flow = cash_flow_df.loc[cy, 'operatingCashFlow']
        if op_cash_flow > 0:
            score += 1
            criteria_met.append("Positive Operating Cash Flow")

        # 3. Return On Assets (ROA) Trend (Profitability)
        total_assets_cy = balance_df.loc[cy, 'totalAssets']
        total_assets_py = balance_df.loc[py, 'totalAssets']
        roa_cy = net_income / total_assets_cy
        roa_py = income_df.loc[py, 'netIncome'] / total_assets_py
        if roa_cy > roa_py:
            score += 1
            criteria_met.append("Increasing Return on Assets (ROA)")

        # 4. Quality of Earnings (Profitability)
        if op_cash_flow > net_income:
            score += 1
            criteria_met.append("Operating Cash Flow > Net Income")

        # 5. Long-Term Debt vs Assets (Leverage)
        debt_cy = balance_df.loc[cy, 'longTermDebt'] / total_assets_cy
        debt_py = balance_df.loc[py, 'longTermDebt'] / total_assets_py
        if debt_cy < debt_py:
            score += 1
            criteria_met.append("Lower Long-term Debt Ratio")

        # 6. Current Ratio Trend (Liquidity)
        current_ratio_cy = balance_df.loc[cy, 'totalCurrentAssets'] / balance_df.loc[cy, 'totalCurrentLiabilities']
        current_ratio_py = balance_df.loc[py, 'totalCurrentAssets'] / balance_df.loc[py, 'totalCurrentLiabilities']
        if current_ratio_cy > current_ratio_py:
            score += 1
            criteria_met.append("Higher Current Ratio")

        # 7. Shares Outstanding (Dilution)
        shares_cy = income_df.loc[cy, 'weightedAverageShsOut']
        shares_py = income_df.loc[py, 'weightedAverageShsOut']
        if shares_cy <= shares_py:
            score += 1
            criteria_met.append("No new shares issued (no dilution)")

        # 8. Gross Margin Trend (Operating Efficiency)
        gross_margin_cy = income_df.loc[cy, 'grossProfit'] / income_df.loc[cy, 'revenue']
        gross_margin_py = income_df.loc[py, 'grossProfit'] / income_df.loc[py, 'revenue']
        if gross_margin_cy > gross_margin_py:
            score += 1
            criteria_met.append("Higher Gross Margin")

        # 9. Asset Turnover Trend (Operating Efficiency)
        asset_turnover_cy = income_df.loc[cy, 'revenue'] / total_assets_py
        asset_turnover_py = income_df.loc[py, 'revenue'] / (balance_df.iloc[-3]['totalAssets'] if len(balance_df) > 2 else total_assets_py)
        if asset_turnover_cy > asset_turnover_py:
            score += 1
            criteria_met.append("Higher Asset Turnover Ratio")
            
    except Exception as e:
        print(f"Could not calculate Piotroski score due to missing data or error: {e}")
        return {"score": 0, "criteria": [f"Piotroski calculation error: {e}"]}

    return {"score": score, "criteria": criteria_met}


def calculate_graham_scan(profile: dict, key_metrics: dict, income_statements: list):
    """
    Performs a Benjamin Graham scan based on 7 tenets for the defensive investor.
    """
    score = 0
    criteria_met = []

    if not profile or not key_metrics or len(income_statements) < 5:
        return {"score": 0, "criteria": ["Not enough historical data for a full Graham scan."]}

    try:
        # Tenet 1: Adequate Size (Market Cap > $2 Billion)
        market_cap = profile.get('mktCap')
        if market_cap and market_cap > 2_000_000_000:
            score += 1
            criteria_met.append(f"Adequate Size (Market Cap: ${market_cap / 1_000_000_000:.2f}B)")

        # Tenet 2: Strong Financial Condition (Current Ratio > 2.0)
        current_ratio = key_metrics.get('currentRatioTTM')
        if current_ratio and current_ratio > 2.0:
            score += 1
            criteria_met.append(f"Strong Financials (Current Ratio: {current_ratio:.2f})")

        # Tenet 3: Earnings Stability (Positive earnings for the last 5 years)
        earnings_stable = all(stmt.get('netIncome', 0) > 0 for stmt in income_statements)
        if earnings_stable:
            score += 1
            criteria_met.append("Earnings Stability (5 consecutive years of profit)")

        # Tenet 4: Dividend Record (Consistent dividends for the last 5 years)
        dividend_record = all(stmt.get('dividendsPaid', 0) != 0 for stmt in income_statements)
        if dividend_record:
            score += 1
            criteria_met.append("Consistent Dividend Record (5 years)")
        
        # Tenet 5: Earnings Growth (At least 33% growth over 5 years)
        eps_start = income_statements[-1].get('eps')
        eps_end = income_statements[0].get('eps')
        if eps_start is not None and eps_end is not None and eps_start > 0:
            growth = ((eps_end / eps_start) - 1) * 100
            if growth >= 33:
                score += 1
                criteria_met.append(f"Earnings Growth (>33% over 5 years, actual: {growth:.2f}%)")

        # Tenet 6: Moderate P/E Ratio (P/E < 15)
        pe_ratio = key_metrics.get('peRatioTTM')
        if pe_ratio and 0 < pe_ratio < 15:
            score += 1
            criteria_met.append(f"Moderate P/E Ratio (< 15, actual: {pe_ratio:.2f})")

        # Tenet 7: Moderate Price-to-Book (P/E * P/B < 22.5)
        pb_ratio = key_metrics.get('priceToBookRatioTTM')
        if pe_ratio and pb_ratio and (pe_ratio * pb_ratio) < 22.5:
            score += 1
            criteria_met.append(f"Moderate P/B Ratio (P/E * P/B < 22.5, actual: {(pe_ratio * pb_ratio):.2f})")

    except Exception as e:
        print(f"Error calculating Graham Scan: {e}")
        return {"score": score, "criteria": criteria_met + [f"Calculation error: {e}"]}

    return {"score": score, "criteria": criteria_met}
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "proxy": "http://localhost:8000",
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.13.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-gauge-chart": "^0.5.1",
    "react-icons": "^5.5.0",
    "react-router-dom": "^7.9.5",
    "react-scripts": "5.0.1",
    "recharts": "^3.3.0",
    "styled-components": "^6.1.19",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</file>

<file path="frontend/src/components/Forecasts/Forecasts.js">
import React, { useState, useEffect } from 'react';
import styled, { keyframes } from 'styled-components';
import axios from 'axios';
import Card from '../common/Card';
import PriceTarget from './PriceTarget';
import AnalystRating from './AnalystRating';

// --- Styled Components ---

const fadeIn = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;

const ForecastGrid = styled.div`
  display: grid;
  grid-template-columns: 1.5fr 1fr; /* Make the left column (Price Target) wider */
  gap: 3rem;

  @media (max-width: 1200px) {
    grid-template-columns: 1fr;
  }
`;

const LeftColumn = styled.div``;
const RightColumn = styled.div``;

const AiAnalysisContainer = styled.div`
  margin-top: 3rem;
  padding-top: 2rem;
  border-top: 1px solid var(--color-border);
`;

const SectionTitle = styled.h3`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 1rem;
  color: var(--color-text-primary);
`;

const AiSummaryText = styled.p`
  font-size: 1rem;
  color: var(--color-text-secondary);
  line-height: 1.8;
  white-space: pre-wrap; /* Respects newlines from the AI's response */
  animation: ${fadeIn} 0.5s ease-in;
`;

const Loader = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  height: 150px;
  color: var(--color-primary);
`;

// --- The Upgraded React Component ---

// The component now accepts the 'currency' prop to pass down to its children.
const Forecasts = ({ symbol, quote, analystRatings, priceTarget, keyStats, news, currency, delay }) => {
  const [aiAnalysis, setAiAnalysis] = useState('');
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchAiAnalysis = async () => {
      // Guard clause to ensure all necessary data is present before making the API call.
      if (!symbol || !analystRatings || !priceTarget || !keyStats || !news || !quote) {
        setIsLoading(false);
        return;
      }
      
      setIsLoading(true);
      try {
        const payload = {
          companyName: quote.name || symbol,
          analystRatings: analystRatings,
          priceTarget: priceTarget,
          keyStats: keyStats,
          newsHeadlines: news.map(n => n.title).slice(0, 10),
        };
        const response = await axios.post(`/api/stocks/${symbol}/forecast-analysis`, payload);
        setAiAnalysis(response.data.analysis);
      } catch (error) {
        console.error("Failed to fetch AI forecast analysis:", error);
        setAiAnalysis("Could not generate AI-powered forecast analysis at this time.");
      } finally {
        setIsLoading(false);
      }
    };

    // Use a setTimeout to stagger this lazy-loaded API call.
    const timer = setTimeout(() => {
        fetchAiAnalysis();
    }, delay || 0);

    // Cleanup function to prevent memory leaks.
    return () => clearTimeout(timer);
  }, [symbol, quote, analystRatings, priceTarget, keyStats, news, delay]); // Dependency array


  // Main render check: if there's no analyst or price target data, show a clear message.
  if (!priceTarget || !analystRatings || Object.keys(priceTarget).length === 0) {
    return (
      <Card>
        <p>Forecast data is not available for this stock.</p>
      </Card>
    );
  }

  return (
    <Card>
      <ForecastGrid>
        <LeftColumn>
          {/* We now pass the 'currency' prop down to the PriceTarget component */}
          <PriceTarget consensus={priceTarget} quote={quote} currency={currency} />
        </LeftColumn>
        <RightColumn>
          <AnalystRating ratingsData={analystRatings} />
        </RightColumn>
      </ForecastGrid>

      <AiAnalysisContainer>
        <SectionTitle>AI-Powered Analysis</SectionTitle>
        {isLoading ? (
          <Loader>Generating AI summary...</Loader>
        ) : (
          <AiSummaryText>{aiAnalysis}</AiSummaryText>
        )}
      </AiAnalysisContainer>
    </Card>
  );
};

export default Forecasts;
</file>

<file path="frontend/src/components/Fundamentals/FundamentalConclusion.js">
import React, { useMemo } from 'react';
import styled, { keyframes } from 'styled-components';

// --- Styled Components & Animations ---

const fadeIn = keyframes`
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;

const SectionContainer = styled.div`
  animation: ${fadeIn} 0.5s ease-out;
`;

const SectionTitle = styled.h3`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 1.5rem;
  color: var(--color-text-primary);
`;

const ConclusionGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 2fr;
  gap: 2rem;
  align-items: center;

  @media (max-width: 992px) {
    grid-template-columns: 1fr;
  }
`;

const GradeCircle = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 200px;
  height: 200px;
  border-radius: 50%;
  // A beautiful gradient background for the inner circle
  background: radial-gradient(circle, var(--color-secondary) 60%, transparent 61%);
  // A thick, vibrant border whose color is determined by the grade
  border: 8px solid ${({ color }) => color};
  // A subtle glow effect that matches the border color
  box-shadow: 0 0 25px ${({ color }) => color}33;
  margin: 0 auto;
  transition: all 0.5s ease-in-out;
`;

const GradeText = styled.span`
  font-size: 5rem;
  font-weight: 800;
  line-height: 1;
  color: ${({ color }) => color};
`;

const ThesisText = styled.p`
  font-size: 1.5rem;
  font-weight: 500;
  color: var(--color-text-primary);
  line-height: 1.6;
  margin-bottom: 2rem;
  text-align: center;
  border-left: 3px solid var(--color-primary);
  padding-left: 1.5rem;
`;

const TakeawaysList = styled.ul`
  list-style-type: none;
  padding-left: 0;
`;

const TakeawayItem = styled.li`
  margin-bottom: 1rem;
  color: var(--color-text-secondary);
  display: flex;
  align-items: flex-start;
  line-height: 1.6;

  &::before {
    content: '▪';
    color: var(--color-primary);
    margin-right: 12px;
    font-size: 1.5rem;
    line-height: 1.6;
  }
`;

// --- The Component ---

const FundamentalConclusion = ({ conclusionData }) => {
  
  // --- ROBUST PARSING LOGIC ---
  // This parser handles variations in the AI's output format.
  const parsedConclusion = useMemo(() => {
    // Default state if data is missing
    if (!conclusionData) {
      return { grade: 'N/A', thesis: 'Waiting for analysis...', takeaways: [] };
    }
    
    const lines = conclusionData.split('\n');
    let grade = 'N/A';
    let thesis = 'No thesis generated.';
    let takeaways = [];

    lines.forEach(line => {
      const cleanLine = line.trim();
      const upperLine = cleanLine.toUpperCase();

      // Robust detection of the Grade
      if (upperLine.startsWith('GRADE:')) {
        // Extract just the grade letter (e.g., "B+")
        const parts = cleanLine.split(':');
        if (parts.length > 1) {
            grade = parts[1].trim().split(' ')[0]; 
        }
      } 
      // Robust detection of the Thesis
      else if (upperLine.startsWith('THESIS:')) {
        const parts = cleanLine.split(':');
        if (parts.length > 1) {
            thesis = parts[1].trim();
        }
      } 
      // Robust detection of Takeaways (bullets)
      else if (cleanLine.startsWith('-') || cleanLine.startsWith('•') || cleanLine.startsWith('*')) {
         const point = cleanLine.replace(/^[\-\•\*]\s?/, '').trim();
         if (point.length > 5) { // Filter out empty or tiny lines
             takeaways.push(point);
         }
      }
    });
    
    // Fallback: If the AI returned text but our parser missed the bullets,
    // try to grab the last few significant lines as takeaways.
    if (takeaways.length === 0 && conclusionData.length > 50) {
       takeaways = lines.slice(-3).filter(l => l.length > 10);
    }

    return { grade, thesis, takeaways };
  }, [conclusionData]);

  // Helper to pick a color based on the grade letter
  const getGradeColor = (grade) => {
    if (!grade) return 'var(--color-text-secondary)';
    const g = grade.toUpperCase();
    if (g.includes('A')) return 'var(--color-success)';
    if (g.includes('B')) return '#34D399'; // Lighter Green
    if (g.includes('C')) return '#EDBB5A'; // Yellow
    if (g.includes('D')) return '#F88149'; // Orange
    if (g.includes('F')) return 'var(--color-danger)';
    return 'var(--color-text-secondary)';
  };
  
  const gradeColor = getGradeColor(parsedConclusion.grade);

  return (
    <SectionContainer>
      <SectionTitle>Analyst's Conclusion</SectionTitle>
      
      <ThesisText>"{parsedConclusion.thesis}"</ThesisText>
      
      <ConclusionGrid>
        <GradeCircle color={gradeColor}>
          <GradeText color={gradeColor}>{parsedConclusion.grade}</GradeText>
        </GradeCircle>
        <div>
          <h4 style={{ fontWeight: 600, color: 'var(--color-text-primary)', marginBottom: '1rem' }}>Key Takeaways:</h4>
          <TakeawaysList>
            {parsedConclusion.takeaways.map((item, index) => (
              <TakeawayItem key={index}>{item}</TakeawayItem>
            ))}
          </TakeawaysList>
        </div>
      </ConclusionGrid>
    </SectionContainer>
  );
};

export default FundamentalConclusion;
</file>

<file path="frontend/src/components/Shareholding/DonutChart.js">
import React from 'react';
import styled, { keyframes } from 'styled-components';
import { PieChart, Pie, Cell, ResponsiveContainer } from 'recharts';
import { FaChartPie } from 'react-icons/fa'; // Import an icon for the placeholder

// --- Styled Components ---

const fadeIn = keyframes`
  from { opacity: 0; }
  to { opacity: 1; }
`;

const ChartWrapper = styled.div`
  width: 100%;
  height: 350px;
  position: relative;
`;

// --- NEW: Beautiful Placeholder Styles ---
const PlaceholderContainer = styled.div`
  width: 100%;
  height: 350px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: rgba(255, 255, 255, 0.02);
  border-radius: 12px;
  border: 1px dashed var(--color-border);
  padding: 2rem;
  text-align: center;
  animation: ${fadeIn} 0.5s ease-in;
`;

const PlaceholderIcon = styled.div`
  font-size: 3rem;
  color: var(--color-text-secondary);
  margin-bottom: 1rem;
  opacity: 0.5;
`;

const PlaceholderTitle = styled.h4`
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--color-text-primary);
  margin-bottom: 0.5rem;
`;

const DisclaimerText = styled.p`
  font-size: 0.9rem;
  color: var(--color-text-secondary);
  line-height: 1.6;
  max-width: 80%;
  margin: 0 auto;
  font-style: italic;
`;

// --- The Upgraded React Component ---

const DonutChart = ({ breakdown }) => {
  // Define our professional color palette.
  const COLORS = {
    Promoter: '#3B82F6', // Blue
    FII: '#10B981',      // Green
    DII: '#F59E0B',      // Amber/Yellow
    Public: '#EF4444',   // Red
  };

  // --- LOGIC CHECK: Do we have valid data? ---
  // If breakdown is missing, empty, or has 'public' as undefined, we treat it as missing.
  const hasData = breakdown && Object.keys(breakdown).length > 0 && breakdown.public !== undefined;

  // If NO data, render the beautiful placeholder
  if (!hasData) {
      return (
          <PlaceholderContainer>
              <PlaceholderIcon>
                  <FaChartPie />
              </PlaceholderIcon>
              <PlaceholderTitle>Data Coming Soon</PlaceholderTitle>
              <DisclaimerText>
                  Detailed shareholding patterns for this specific region are currently being integrated into our system. 
                  <br />
                  This section is a placeholder and will be updated automatically once the data source is live.
              </DisclaimerText>
          </PlaceholderContainer>
      );
  }

  // --- Data Processing (Only runs if we have data) ---
  const chartData = [
    { name: 'Promoter', value: breakdown.promoter, color: COLORS.Promoter },
    { name: 'FII', value: breakdown.fii, color: COLORS.FII },
    { name: 'DII', value: breakdown.dii, color: COLORS.DII },
    { name: 'Public', value: breakdown.public, color: COLORS.Public },
  ].filter(entry => entry.value > 0.01);

  const renderCustomizedLabel = ({ cx, cy, midAngle, innerRadius, outerRadius, percent, name }) => {
    const RADIAN = Math.PI / 180;
    const radius = outerRadius * 1.4; 
    const x = cx + radius * Math.cos(-midAngle * RADIAN);
    const y = cy + radius * Math.sin(-midAngle * RADIAN);

    return (
      <text
        x={x}
        y={y}
        fill="var(--color-text-primary)"
        textAnchor={x > cx ? 'start' : 'end'}
        dominantBaseline="central"
        fontSize="14px"
        fontWeight="600"
      >
        {`${name} ${(percent * 100).toFixed(1)}%`}
      </text>
    );
  };

  return (
    <ChartWrapper>
      <ResponsiveContainer>
        <PieChart margin={{ top: 40, right: 40, bottom: 40, left: 40 }}>
          <Pie
            data={chartData}
            cx="50%"
            cy="50%"
            innerRadius={80}
            outerRadius={120}
            fill="#8884d8"
            paddingAngle={5}
            dataKey="value"
            nameKey="name"
            labelLine={false}
            label={renderCustomizedLabel}
          >
            {chartData.map((entry) => (
              <Cell key={`cell-${entry.name}`} fill={entry.color} stroke={entry.color} />
            ))}
          </Pie>
        </PieChart>
      </ResponsiveContainer>
    </ChartWrapper>
  );
};

export default DonutChart;
</file>

<file path="frontend/src/components/Shareholding/Shareholding.js">
import React from 'react';
import styled from 'styled-components';
import Card from '../common/Card';
import DonutChart from './DonutChart';
import TrendChart from './TrendChart';
import OwnershipTrend from './OwnershipTrend';

// --- Styled Components ---

const GridContainer = styled.div`
  display: grid;
  /* Create two columns of equal width */
  grid-template-columns: 1fr 1fr; 
  gap: 2rem; /* Space between the two charts */
  align-items: center; /* Vertically align the content */
  
  /* On smaller screens, stack the charts on top of each other */
  @media (max-width: 1200px) {
    grid-template-columns: 1fr;
  }
`;

const ChartContainer = styled.div`
  width: 100%;
`;

const SectionTitle = styled.h3`
    font-size: 1.2rem;
    font-weight: 500;
    color: var(--color-text-secondary);
    text-align: center;
    margin-bottom: 2rem;
`;

// --- The Upgraded React Component ---

// It now accepts 'historicalStatements' instead of 'historicalOwnership'
const Shareholding = ({ shareholdingData, historicalStatements, shareholdingBreakdown }) => {

  // Defensive check: If there's no current shareholding data, show a message.
  if (!shareholdingData || !Array.isArray(shareholdingData) || shareholdingData.length === 0) {
    return (
      <Card title="Shareholding">
        <p>Shareholding data is not available for this stock.</p>
      </Card>
    );
  }

  return (
    <Card title="Shareholding">
      {/* --- This top section for summary charts is unchanged --- */}
      <GridContainer>
        <ChartContainer>
          <SectionTitle>Summary</SectionTitle>
          <DonutChart breakdown={shareholdingBreakdown} />

        </ChartContainer>
        <ChartContainer>
           <TrendChart />
        </ChartContainer>
      </GridContainer>

      {/* --- THIS IS THE UPDATED PART --- */}
      {/* We now pass the 'historicalStatements' prop to our new OwnershipTrend component. */}
      {/* This component will now render the Shares Outstanding trend chart. */}
      <OwnershipTrend historicalStatements={historicalStatements} />

    </Card>
  );
};

export default Shareholding;
</file>

<file path="frontend/src/components/Technicals/RatingDial.js">
import React from 'react';
import styled from 'styled-components';
import GaugeChart from 'react-gauge-chart';

// --- Styled Components (No changes here) ---

const DialContainer = styled.div`
  width: 100%;
  max-width: 400px;
  margin: 0 auto;
`;

const RatingText = styled.div`
  font-size: 2rem;
  font-weight: 700;
  text-align: center;
  margin-top: -30px;
  color: ${({ $ratingColor }) => $ratingColor};
`;

// --- The React Component (Logic is now more robust) ---

const RatingDial = ({ rating }) => {
  const getRatingDetails = () => {
    // --- THIS IS THE CRITICAL FIX ---
    // We add a "guard clause". If the rating prop is missing or not a string,
    // we default to a Neutral state immediately. This prevents the .toLowerCase() error.
    if (!rating || typeof rating !== 'string') {
      return { percent: 0.5, color: 'var(--color-text-secondary)', text: 'Neutral' };
    }

    // The rest of the logic remains the same
    switch (rating.toLowerCase()) {
      case 'strong buy':
      case 'bullish':
      case 'very bullish':
        return { percent: 0.9, color: 'var(--color-success)', text: 'Strong Buy' };
      case 'buy':
      case 'outperform':
        return { percent: 0.7, color: 'var(--color-success)', text: 'Buy' };
      case 'hold':
      case 'neutral':
        return { percent: 0.5, color: '#EDBB5A', text: 'Hold' };
      case 'sell':
      case 'underperform':
        return { percent: 0.3, color: 'var(--color-danger)', text: 'Sell' };
      case 'strong sell':
      case 'bearish':
        return { percent: 0.1, color: 'var(--color-danger)', text: 'Strong Sell' };
      default:
        return { percent: 0.5, color: 'var(--color-text-secondary)', text: 'Neutral' };
    }
  };

  const { percent, color, text } = getRatingDetails();

  return (
    <DialContainer>
      <GaugeChart
        id="technical-rating-gauge"
        nrOfLevels={30}
        colors={['#F85149', '#EDBB5A', '#3FB950']}
        arcWidth={0.3}
        percent={percent}
        textColor={'transparent'}
        needleBaseColor={'#FFFFFF'}
        needleColor={'#C9D1D9'}
        animate={true}
        animDelay={500}
      />
        <RatingText $ratingColor={color}>
        {text}
      </RatingText>
    </DialContainer>
  );
};

export default RatingDial;
</file>

<file path="frontend/src/components/Technicals/Technicals.js">
import React from 'react';
import styled from 'styled-components';
import Card from '../common/Card';
import RatingDial from './RatingDial';
import PivotLevels from './PivotLevels';
import MovingAverages from './MovingAverages';
import TechnicalIndicatorsTable from './TechnicalIndicatorsTable';

// --- Styled Components ---

const TopSectionGrid = styled.div`
  display: grid;
  /* Two columns: the dial takes up more space than the table */
  grid-template-columns: 2fr 1fr; 
  gap: 2rem;
  align-items: center;
  padding-bottom: 2rem;
  
  /* On smaller screens, stack them */
  @media (max-width: 992px) {
    grid-template-columns: 1fr;
  }
`;

const BottomSection = styled.div`
  /* This section will hold our tables */
`;

// --- The Final, Upgraded React Component ---

// The component now accepts all the new data props from its parent, StockDetailPage.
const Technicals = ({ analystRatings, technicalIndicators, movingAverages, pivotPoints }) => {

  // This logic intelligently determines the overall analyst consensus for the dial.
  let latestRating = "Neutral"; // Default value

  if (analystRatings && Array.isArray(analystRatings) && analystRatings.length > 0) {
    // We use the reliable yfinance data structure.
    const ratingData = analystRatings[0];
    const strongBuy = ratingData.ratingStrongBuy || 0;
    const buy = ratingData.ratingBuy || 0;
    const hold = ratingData.ratingHold || 0;
    const sell = ratingData.ratingSell || 0;
    const strongSell = ratingData.ratingStrongSell || 0;

    // A simple but effective algorithm to find the dominant rating.
    if (strongBuy > (sell + strongSell) && strongBuy > hold) {
        latestRating = "Strong Buy";
    } else if ((strongBuy + buy) > (strongSell + sell)) {
        latestRating = "Buy";
    } else if (strongSell > (buy + strongBuy) && strongSell > hold) {
        latestRating = "Strong Sell";
    } else if ((strongSell + sell) > (strongBuy + buy)) {
        latestRating = "Sell";
    } else {
        latestRating = "Hold";
    }
  }

  return (
    <Card title="Technical Summary">
      
      {/* --- Top Section --- */}
      <TopSectionGrid>
        {/* The dial now receives a dynamically calculated rating */}
        <RatingDial rating={latestRating} />
        {/* This component now receives real, dynamic moving average data */}
        <MovingAverages maData={movingAverages} />
      </TopSectionGrid>

      {/* --- Bottom Section --- */}
      <BottomSection>
        {/* This component receives real, dynamic indicator data */}
        <TechnicalIndicatorsTable indicators={technicalIndicators} />
        
        {/* This component now receives real, dynamic pivot point data */}
        <div style={{ marginTop: '2rem' }}>
          <PivotLevels pivotData={pivotPoints} />
        </div>
      </BottomSection>

    </Card>
  );
};

export default Technicals;
</file>

<file path="backend/app/services/technical_service.py">
import pandas as pd
import pandas_ta as ta
import numpy as np

def get_currency_symbol(currency_code: str):
    """
    Converts a currency code (e.g., 'INR') into its corresponding symbol (e.g., '₹').
    """
    symbols = {
        "INR": "₹",
        "USD": "$",
        "JPY": "¥",
        "EUR": "€",
        "GBP": "£",
    }
    return symbols.get(currency_code, "$")

def calculate_darvas_box(hist_df: pd.DataFrame, quote: dict, currency_code: str):
    """
    Analyzes historical price data to identify a Darvas Box pattern.
    """
    if hist_df is None or len(hist_df) < 30 or not quote:
        return {"status": "Insufficient Data", "message": "Not enough historical data to perform scan."}

    try:
        current_price = quote.get('price')
        year_high = quote.get('yearHigh')
        avg_volume = quote.get('avgVolume')
        current_volume = quote.get('volume')

        if not all([current_price, year_high, avg_volume, current_volume]):
             return {"status": "Insufficient Data", "message": "Missing key price or volume data."}
        
        currency_symbol = get_currency_symbol(currency_code)

        if current_price < (year_high * 0.90):
            return {
                "status": "Not a Candidate",
                "message": f"Stock price ({currency_symbol}{current_price:.2f}) is not within 10% of its 52-week high ({currency_symbol}{year_high:.2f})."
            }

        recent_period = hist_df.tail(15)
        box_top = recent_period['high'].max()
        box_bottom = recent_period['low'].min()

        if box_top > box_bottom * 1.08:
            return {
                "status": "No Box Formed",
                "message": "Stock is too volatile and has not formed a narrow consolidation box recently."
            }

        if current_price > box_top:
            volume_check = "on high volume" if current_volume > (avg_volume * 1.5) else "on average volume"
            return {
                "status": "Breakout!",
                "message": f"Stock has broken out above the box top of {currency_symbol}{box_top:.2f} {volume_check}.",
                "box_top": box_top, "box_bottom": box_bottom, "result": "Pass"
            }
        
        elif current_price < box_bottom:
            return {
                "status": "Breakdown",
                "message": f"Stock has broken down below the box bottom of {currency_symbol}{box_bottom:.2f}.",
                "box_top": box_top, "box_bottom": box_bottom, "result": "Fail"
            }
        
        else:
            return {
                "status": "In Box",
                "message": f"Stock is consolidating in a Darvas Box between {currency_symbol}{box_bottom:.2f} and {currency_symbol}{box_top:.2f}.",
                "box_top": box_top, "box_bottom": box_bottom, "result": "Neutral"
            }

    except Exception as e:
        print(f"Error calculating Darvas Box: {e}")
        return {"status": "Calculation Error", "message": str(e)}


def calculate_moving_averages(hist_df: pd.DataFrame):
    """
    Calculates a standard set of Simple Moving Averages (SMA).
    """
    if hist_df is None or hist_df.empty or len(hist_df) < 50: # Reduced requirement slightly
        return {} 
    
    try:
        # Calculate SMAs, checking if enough data exists for 200
        mas = {
            "5": hist_df['close'].rolling(window=5).mean().iloc[-1],
            "10": hist_df['close'].rolling(window=10).mean().iloc[-1],
            "20": hist_df['close'].rolling(window=20).mean().iloc[-1],
            "50": hist_df['close'].rolling(window=50).mean().iloc[-1],
            "100": hist_df['close'].rolling(window=100).mean().iloc[-1] if len(hist_df) >= 100 else None,
            "200": hist_df['close'].rolling(window=200).mean().iloc[-1] if len(hist_df) >= 200 else None,
        }
        return mas
    except Exception as e:
        print(f"Error calculating moving averages: {e}")
        return {}

def calculate_pivot_points(hist_df: pd.DataFrame):
    """
    Calculates Classic, Fibonacci, and Camarilla Pivot Points.
    """
    if hist_df is None or len(hist_df) < 2:
        return {} 
        
    try:
        prev_day = hist_df.iloc[-2]
        high = prev_day['high']
        low = prev_day['low']
        close = prev_day['close']
        price_range = high - low

        # Classic
        pivot_classic = (high + low + close) / 3
        classic = {
            "pp": pivot_classic, "r1": (2 * pivot_classic) - low, "s1": (2 * pivot_classic) - high,
            "r2": pivot_classic + price_range, "s2": pivot_classic - price_range,
            "r3": high + 2 * (pivot_classic - low), "s3": low - 2 * (high - pivot_classic)
        }

        # Fibonacci
        fibonacci = {
            "pp": pivot_classic, "r1": pivot_classic + (0.382 * price_range), "s1": pivot_classic - (0.382 * price_range),
            "r2": pivot_classic + (0.618 * price_range), "s2": pivot_classic - (0.618 * price_range),
            "r3": pivot_classic + (1.000 * price_range), "s3": pivot_classic - (1.000 * price_range)
        }

        # Camarilla
        camarilla = {
            "pp": pivot_classic,
            "r1": close + (price_range * 1.1 / 12), "s1": close - (price_range * 1.1 / 12),
            "r2": close + (price_range * 1.1 / 6), "s2": close - (price_range * 1.1 / 6),
            "r3": close + (price_range * 1.1 / 4), "s3": close - (price_range * 1.1 / 4)
        }

        return { "classic": classic, "fibonacci": fibonacci, "camarilla": camarilla }
    except Exception as e:
        print(f"Error calculating pivot points: {e}")
        return {}

# --- NEW: ADVANCED INDICATOR ENGINE FOR CHART AI ---
def calculate_advanced_technicals(hist_df: pd.DataFrame):
    """
    Calculates specific indicators for the Chart Analysis tab:
    MACD, RSI, Stochastic RSI, EMA.
    """
    if hist_df is None or hist_df.empty: return {}
    
    try:
        # Calculate using pandas_ta
        # We use try-except blocks for individual indicators to prevent total failure
        
        # 1. RSI (14)
        try: hist_df.ta.rsi(length=14, append=True)
        except: pass
        
        # 2. Stochastic RSI
        try: hist_df.ta.stochrsi(length=14, rsi_length=14, k=3, d=3, append=True)
        except: pass
        
        # 3. MACD
        try: hist_df.ta.macd(fast=12, slow=26, signal=9, append=True)
        except: pass
        
        # 4. EMAs
        try:
            hist_df.ta.ema(length=20, append=True)
            hist_df.ta.ema(length=50, append=True)
            hist_df.ta.ema(length=200, append=True)
        except: pass

        latest = hist_df.iloc[-1]
        
        return {
            "rsi": latest.get('RSI_14'),
            "stoch_rsi_k": latest.get('STOCHRSIk_14_14_3_3'),
            "stoch_rsi_d": latest.get('STOCHRSId_14_14_3_3'),
            "macd": latest.get('MACD_12_26_9'),
            "macd_signal": latest.get('MACDs_12_26_9'),
            "ema_20": latest.get('EMA_20'),
            "ema_50": latest.get('EMA_50'),
            "ema_200": latest.get('EMA_200'),
            "current_price": latest.get('close')
        }
    except Exception as e:
        print(f"Error calculating advanced technicals: {e}")
        return {}

# --- NEW: ALGORITHMIC SUPPORT & RESISTANCE ---
def calculate_support_resistance_levels(hist_df: pd.DataFrame):
    """
    Identifies key Support and Resistance levels using local minima and maxima (Fractals).
    """
    if hist_df is None or len(hist_df) < 20: return {"supports": [], "resistances": []}

    try:
        # We look for "Fractals" - a high surrounded by lower highs, or low surrounded by higher lows.
        window = 3 # Smaller window for faster detection
        
        levels = []
        
        for i in range(window, len(hist_df) - window):
            # Check for Support (Local Low)
            is_support = True
            for j in range(1, window + 1):
                if hist_df['low'].iloc[i] > hist_df['low'].iloc[i-j] or hist_df['low'].iloc[i] > hist_df['low'].iloc[i+j]:
                    is_support = False
                    break
            if is_support:
                levels.append((hist_df.index[i], hist_df['low'].iloc[i], "Support"))

            # Check for Resistance (Local High)
            is_resistance = True
            for j in range(1, window + 1):
                if hist_df['high'].iloc[i] < hist_df['high'].iloc[i-j] or hist_df['high'].iloc[i] < hist_df['high'].iloc[i+j]:
                    is_resistance = False
                    break
            if is_resistance:
                levels.append((hist_df.index[i], hist_df['high'].iloc[i], "Resistance"))

        current_price = hist_df['close'].iloc[-1]
        
        # Sort by proximity to current price
        # Filter for supports below price
        supports = sorted([x[1] for x in levels if x[2] == "Support" and x[1] < current_price], key=lambda x: abs(x - current_price))[:3]
        # Filter for resistances above price
        resistances = sorted([x[1] for x in levels if x[2] == "Resistance" and x[1] > current_price], key=lambda x: abs(x - current_price))[:3]
        
        return {
            "supports": sorted(supports, reverse=True), # Highest supports first
            "resistances": sorted(resistances) # Lowest resistances first
        }

    except Exception as e:
        print(f"Error calculating S/R levels: {e}")
        return {"supports": [], "resistances": []}

# ... (Keep existing calculate_darvas_box, calculate_moving_averages, calculate_pivot_points) ...

def calculate_extended_technicals(df: pd.DataFrame):
    """
    Calculates a comprehensive suite of indicators: RSI, StochRSI, MACD, EMA, and Pivots.
    Designed for multi-timeframe analysis.
    """
    if df is None or df.empty or len(df) < 50:
        return None

    try:
        # 1. Standard Indicators (RSI, MACD)
        df.ta.rsi(length=14, append=True)
        df.ta.macd(fast=12, slow=26, signal=9, append=True)
        
        # 2. Stochastic RSI (The "StochRSI" user requested)
        df.ta.stochrsi(length=14, rsi_length=14, k=3, d=3, append=True)

        # 3. Exponential Moving Averages (EMA)
        df.ta.ema(length=9, append=True)  # Fast EMA
        df.ta.ema(length=21, append=True) # Medium EMA
        df.ta.ema(length=50, append=True) # Slow EMA
        df.ta.ema(length=200, append=True) # Trend EMA

        # Get the latest row
        latest = df.iloc[-1]
        
        # 4. Calculate Pivot Points (Support/Resistance)
        # We reuse our existing logic but apply it here locally
        prev_day = df.iloc[-2]
        pp = (prev_day['high'] + prev_day['low'] + prev_day['close']) / 3
        r1 = (2 * pp) - prev_day['low']
        s1 = (2 * pp) - prev_day['high']
        r2 = pp + (prev_day['high'] - prev_day['low'])
        s2 = pp - (prev_day['high'] - prev_day['low'])

        return {
            "price": latest['close'],
            "rsi": latest.get('RSI_14'),
            "stoch_k": latest.get('STOCHRSIk_14_14_3_3'),
            "stoch_d": latest.get('STOCHRSId_14_14_3_3'),
            "macd": latest.get('MACD_12_26_9'),
            "macd_signal": latest.get('MACDs_12_26_9'),
            "ema_9": latest.get('EMA_9'),
            "ema_21": latest.get('EMA_21'),
            "ema_50": latest.get('EMA_50'),
            "ema_200": latest.get('EMA_200'),
            "support": {"s1": s1, "s2": s2},
            "resistance": {"r1": r1, "r2": r2},
            "pivot": pp
        }
    except Exception as e:
        print(f"Error calculating extended technicals: {e}")
        return None
</file>

<file path="frontend/src/components/common/Tabs/Tabs.js">
import React, { useState, useRef, Children, isValidElement } from 'react';
import styled from 'styled-components';
import { FaChevronLeft, FaChevronRight } from 'react-icons/fa';

// --- Styled Components ---

const TabsContainer = styled.div`
  width: 100%;
  position: relative; /* Needed for absolute positioning of arrows */
`;

const TabListWrapper = styled.div`
  position: relative;
  display: flex;
  align-items: center;
  border-bottom: 2px solid var(--color-border);
`;

const TabList = styled.div`
  display: flex;
  overflow-x: auto;
  scroll-behavior: smooth;
  width: 100%;
  
  /* Hide scrollbar for a clean, native-app feel */
  &::-webkit-scrollbar {
    display: none;
  }
  -ms-overflow-style: none;  /* IE and Edge */
  scrollbar-width: none;  /* Firefox */
`;

const TabButton = styled.button`
  padding: 1rem 1.5rem;
  border: none;
  background-color: transparent;
  color: ${({ active }) => (active ? 'var(--color-text-primary)' : 'var(--color-text-secondary)')};
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  position: relative;
  transition: color 0.3s ease;
  white-space: nowrap; /* Critical: prevents text from wrapping */
  flex-shrink: 0; /* Critical: prevents buttons from squishing */

  &:hover {
    color: var(--color-text-primary);
  }

  &::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 0;
    width: 100%;
    height: 2px;
    background-color: var(--color-primary);
    transform: ${({ active }) => (active ? 'scaleX(1)' : 'scaleX(0)')};
    transform-origin: bottom;
    transition: transform 0.3s ease-out;
  }
`;

// --- The Scroll Arrow Buttons ---
const ScrollButton = styled.button`
  position: absolute;
  top: 0;
  bottom: 0;
  width: 40px;
  border: none;
  cursor: pointer;
  z-index: 2;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--color-primary);
  font-size: 1rem;
  transition: opacity 0.2s;
  
  /* High-end gradient effect to fade content behind the arrow */
  &.left {
    left: 0;
    background: linear-gradient(to right, var(--color-background) 40%, transparent 100%);
  }
  
  &.right {
    right: 0;
    background: linear-gradient(to left, var(--color-background) 40%, transparent 100%);
  }

  &:hover {
    color: var(--color-text-primary);
  }

  /* Only show arrows on devices where scrolling might be needed */
  @media (min-width: 768px) {
     /* Optional: You can hide them on large desktop if you prefer, 
        but keeping them ensures usability everywhere */
  }
`;

const TabContentContainer = styled.div`
  padding: 2rem 0;
`;

const TabPanelWrapper = styled.div`
  display: ${({ active }) => (active ? 'block' : 'none')};
`;


// --- The Logic ---

const Tabs = ({ children }) => {
  const validChildren = Children.toArray(children).filter(isValidElement);
  const [activeTab, setActiveTab] = useState(validChildren[0]?.props.label);
  const scrollRef = useRef(null);

  const handleClick = (e, newActiveTab) => {
    e.preventDefault();
    setActiveTab(newActiveTab);
    
    // Optional: Auto-scroll the active tab into view
    e.target.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
  };

  const scroll = (direction) => {
    if (scrollRef.current) {
      const { current } = scrollRef;
      const scrollAmount = 200; // Adjust scroll speed
      if (direction === 'left') {
        current.scrollLeft -= scrollAmount;
      } else {
        current.scrollLeft += scrollAmount;
      }
    }
  };

  return (
    <TabsContainer>
      <TabListWrapper>
        {/* Left Arrow */}
        <ScrollButton className="left" onClick={() => scroll('left')} aria-label="Scroll Left">
          <FaChevronLeft />
        </ScrollButton>

        <TabList ref={scrollRef}>
          {validChildren.map(child => (
            <TabButton
              key={child.props.label}
              active={activeTab === child.props.label}
              onClick={e => handleClick(e, child.props.label)}
            >
              {child.props.label}
            </TabButton>
          ))}
        </TabList>

        {/* Right Arrow */}
        <ScrollButton className="right" onClick={() => scroll('right')} aria-label="Scroll Right">
          <FaChevronRight />
        </ScrollButton>
      </TabListWrapper>

      <TabContentContainer>
        {validChildren.map(child => (
          <TabPanelWrapper
            key={child.props.label}
            active={activeTab === child.props.label}
          >
            {child.props.children}
          </TabPanelWrapper>
        ))}
      </TabContentContainer>
    </TabsContainer>
  );
};

const TabPanel = ({ label, children }) => {
  return <div label={label}>{children}</div>;
};

export { Tabs, TabPanel };
</file>

<file path="frontend/src/components/Financials/Financials.js">
import React from 'react';
import styled from 'styled-components';

// --- Import all our components ---
import Card from '../common/Card';
import RevenueChart from './RevenueChart';
import KeyStats from './KeyStats';
import AboutCompany from './AboutCompany';
import BalanceSheet from './BalanceSheet';
// --- NEW: Import our new Financial Statements viewer ---
import FinancialStatements from './FinancialStatements';

// --- Styled Components ---

const FinancialsContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 2rem; /* Adds space between each section */
`;

// --- The Final, Upgraded React Component ---

const Financials = ({
  profile,
  keyStats,
  financialData,
  balanceSheetData,
  // --- NEW: Accepting all the new data props ---
  annualCashFlow,
  quarterlyIncome,
  quarterlyBalance,
  quarterlyCashFlow
}) => {
  // Defensive check: If we don't have the core profile data, show a generic message.
  if (!profile) {
    return (
      <Card>
        <p>Financial data is not available for this stock.</p>
      </Card>
    );
  }

  return (
    <Card>
      <FinancialsContainer>

        {/* --- Section 1: Key Stats (Unchanged) --- */}
        <KeyStats stats={keyStats} />
        
        {/* --- Section 2: Balance Sheet Charts (Unchanged) --- */}
        <BalanceSheet balanceSheetData={balanceSheetData} />

        {/* --- Section 3: Income Statement Chart (Unchanged) --- */}
        <div>
            <h3 style={{ fontSize: '1.5rem', fontWeight: 600, marginBottom: '1.5rem' }}>Income Statement (5-Year Trend)</h3>
            <RevenueChart data={financialData} />
        </div>

        {/* --- Section 4: Detailed Financial Statements Viewer (NEW!) --- */}
        {/* We add our new component here, passing all the necessary annual and quarterly data down to it. */}
        <FinancialStatements
          currency={profile.currency}
          annualIncome={financialData}
          annualBalance={balanceSheetData}
          annualCashFlow={annualCashFlow}
          quarterlyIncome={quarterlyIncome}
          quarterlyBalance={quarterlyBalance}
          quarterlyCashFlow={quarterlyCashFlow}
        />

        {/* --- Section 5: About the Company (Unchanged) --- */}
        <AboutCompany profile={profile} />

      </FinancialsContainer>
    </Card>
  );
};

export default Financials;
</file>

<file path="frontend/src/components/Header/StockHeader.js">
import React from 'react';
import styled from 'styled-components';

// --- Styled Components ---

const HeaderContainer = styled.div`
  display: flex;
  flex-direction: column; /* Default to column for mobile */
  justify-content: space-between;
  align-items: flex-start; /* Align left on mobile */
  margin-bottom: 1.5rem;
  padding: 1.25rem;
  background-color: var(--color-secondary);
  border: 1px solid var(--color-border);
  border-radius: 12px;
  gap: 1rem;
  width: 100%; /* Ensure it takes full width but respects padding */
  box-sizing: border-box;

  @media (min-width: 768px) {
    flex-direction: row; /* Row for desktop */
    align-items: center;
    gap: 0;
    padding: 1.5rem;
    margin-bottom: 2rem;
  }
`;

const CompanyInfo = styled.div`
  display: flex;
  align-items: center;
  gap: 1rem;
  max-width: 100%; /* Prevent overflow */
`;

const CompanyLogo = styled.img`
  width: 48px;
  height: 48px;
  border-radius: 50%;
  background-color: #fff;
  flex-shrink: 0; /* Prevent logo from getting squished */
  
  @media (min-width: 768px) {
      width: 60px;
      height: 60px;
  }
`;

const TextContainer = styled.div`
  display: flex;
  flex-direction: column;
  min-width: 0; /* Critical for text truncation to work in flex items */
`;

const CompanyName = styled.h1`
  font-size: 1.25rem; /* Smaller, safer size for mobile */
  font-weight: 700;
  margin: 0;
  line-height: 1.3;
  
  /* Text Wrapping Logic */
  white-space: normal; 
  word-wrap: break-word;

  @media (min-width: 768px) {
    font-size: 2.5rem;
    white-space: nowrap; /* On desktop, we can keep it on one line */
  }
`;

const CompanySymbol = styled.span`
  font-size: 0.9rem;
  color: var(--color-text-secondary);
  font-weight: 500;
  margin-top: 0.25rem;
  
  @media (min-width: 768px) {
      font-size: 1.2rem;
      margin-top: 0;
      margin-left: 0.75rem;
      display: inline-block; /* Sit next to name on desktop */
  }
`;

const PriceInfo = styled.div`
  text-align: left;
  width: 100%;
  
  @media (min-width: 768px) {
    text-align: right;
    width: auto;
  }
`;

const CurrentPrice = styled.div`
  font-size: 1.75rem; /* Readable but compact for mobile */
  font-weight: 700;
  margin-bottom: 0.25rem;

  @media (min-width: 768px) {
      font-size: 2.5rem;
  }
`;

const PriceChange = styled.div`
  font-size: 1rem;
  font-weight: 500;
  color: ${({ isPositive }) => (isPositive ? 'var(--color-success)' : 'var(--color-danger)')};
  
  @media (min-width: 768px) {
      font-size: 1.2rem;
  }
`;

// --- Helper Function ---
const getCurrencySymbol = (currencyCode) => {
    switch (currencyCode) {
        case 'INR': return '₹';
        case 'USD': return '$';
        case 'JPY': return '¥';
        case 'EUR': return '€';
        case 'GBP': return '£';
        default: return '$';
    }
};

// --- The React Component ---

const StockHeader = ({ profile, quote }) => {
  if (!profile || !quote) return null;
  const currencySymbol = getCurrencySymbol(profile.currency);
  const isPositive = (quote.change || 0) >= 0;

  return (
    <HeaderContainer>
      <CompanyInfo>
        {profile.image && <CompanyLogo src={profile.image} alt={`${profile.companyName} logo`} />}
        <TextContainer>
          <CompanyName>
            {profile.companyName}
            {/* On Desktop, symbol is next to name. On Mobile, we put it below via flex direction logic above */}
            <span style={{ display: 'inline-block' }}>
               <CompanySymbol>{profile.symbol}</CompanySymbol>
            </span>
          </CompanyName>
        </TextContainer>
      </CompanyInfo>
      
      <PriceInfo>
        <CurrentPrice>{currencySymbol}{(quote.price || 0).toFixed(2)}</CurrentPrice>
        <PriceChange isPositive={isPositive}>
            {isPositive ? '+' : ''}{(quote.change || 0).toFixed(2)} ({(quote.changesPercentage || 0).toFixed(2)}%)
        </PriceChange>
      </PriceInfo>
    </HeaderContainer>
  );
};

export default StockHeader;
</file>

<file path="frontend/src/components/SWOT/SwotAnalysis.js">
import React, { useMemo } from 'react';
import styled, { keyframes } from 'styled-components';
import Card from '../common/Card';

// --- Styled Components & Animations ---

const fadeIn = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;

const Loader = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  height: 200px;
  color: var(--color-primary);
  animation: ${fadeIn} 0.5s ease-in;
`;

// The 4-quadrant grid layout
const SwotGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1px; /* Creates the thin border lines */
  background-color: var(--color-border);
  border: 1px solid var(--color-border);
  border-radius: 8px;
  overflow: hidden;
  animation: ${fadeIn} 0.5s ease-in;

  /* Stack vertically on mobile */
  @media (max-width: 768px) {
    grid-template-columns: 1fr;
  }
`;

const SwotQuadrant = styled.div`
  background-color: var(--color-secondary);
  padding: 1.5rem;
  min-height: 200px;
`;

const QuadrantTitle = styled.h4`
  font-size: 1.1rem;
  font-weight: 600;
  margin-bottom: 1rem;
  color: ${({ color }) => color};
  border-bottom: 2px solid ${({ color }) => color};
  padding-bottom: 0.5rem;
  display: inline-block;
`;

const SwotList = styled.ul`
  list-style-type: none;
  padding-left: 0;
  margin-top: 0;
`;

const SwotListItem = styled.li`
  margin-bottom: 0.75rem;
  color: var(--color-text-secondary);
  line-height: 1.6;
  padding-left: 1.5rem;
  position: relative;

  &::before {
    content: '•';
    color: var(--color-primary);
    position: absolute;
    left: 0;
    top: 0;
    font-size: 1.2rem;
    line-height: 1.6;
  }

  &:last-child {
    margin-bottom: 0;
  }
`;

// --- The Component ---

const SwotAnalysis = ({ analysisText, isLoading }) => {

  // --- ROBUST PARSING LOGIC ---
  // This logic is designed to be "fuzzy" and forgiving. 
  // It catches section headers even if the AI changes capitalization or formatting.
  const swotData = useMemo(() => {
    if (!analysisText) return null;

    const data = { Strengths: [], Weaknesses: [], Opportunities: [], Threats: [] };
    const lines = analysisText.split('\n');
    let currentSection = null;

    lines.forEach(line => {
      const cleanLine = line.trim();
      const lowerLine = cleanLine.toLowerCase();

      // Fuzzy matching for headers
      if (lowerLine.includes('strength')) currentSection = 'Strengths';
      else if (lowerLine.includes('weakness')) currentSection = 'Weaknesses';
      else if (lowerLine.includes('opportunit')) currentSection = 'Opportunities';
      else if (lowerLine.includes('threat')) currentSection = 'Threats';
      
      // Check for bullet points
      else if (currentSection && (cleanLine.startsWith('-') || cleanLine.startsWith('*') || cleanLine.startsWith('•'))) {
        // Clean up the content: remove the bullet char and any bold markdown
        const content = cleanLine
            .replace(/^[\-\*\•]\s?/, '') 
            .replace(/\*\*.*?\*\*/g, '') 
            .trim();
        
        // Only add if it's not an empty string
        if (content.length > 2) {
            data[currentSection].push(content);
        }
      }
    });
    return data;
  }, [analysisText]);

  // --- Render Logic ---

  if (isLoading) {
    return (
        <Card title="AI-Powered SWOT Analysis">
            <Loader>Generating AI analysis...</Loader>
        </Card>
    );
  }

  // Fallback: If parsing produced no data (or analysisText was empty), show raw text or message
  if (!swotData || Object.values(swotData).every(arr => arr.length === 0)) {
    return (
      <Card title="AI-Powered SWOT Analysis">
        <p style={{ lineHeight: 1.7, color: 'var(--color-text-secondary)', whiteSpace: 'pre-wrap' }}>
          {analysisText || "Could not generate SWOT analysis for this stock."}
        </p>
      </Card>
    );
  }

  return (
    <Card title="AI-Powered SWOT Analysis">
      <SwotGrid>
        <SwotQuadrant>
          <QuadrantTitle color="var(--color-success)">Strengths</QuadrantTitle>
          <SwotList>
            {swotData.Strengths.map((item, i) => <SwotListItem key={`s-${i}`}>{item}</SwotListItem>)}
          </SwotList>
        </SwotQuadrant>
        
        <SwotQuadrant>
          <QuadrantTitle color="var(--color-danger)">Weaknesses</QuadrantTitle>
          <SwotList>
            {swotData.Weaknesses.map((item, i) => <SwotListItem key={`w-${i}`}>{item}</SwotListItem>)}
          </SwotList>
        </SwotQuadrant>
        
        <SwotQuadrant>
          <QuadrantTitle color="var(--color-primary)">Opportunities</QuadrantTitle>
          <SwotList>
            {swotData.Opportunities.map((item, i) => <SwotListItem key={`o-${i}`}>{item}</SwotListItem>)}
          </SwotList>
        </SwotQuadrant>
        
        <SwotQuadrant>
          <QuadrantTitle color="#EDBB5A">Threats</QuadrantTitle>
          <SwotList>
            {swotData.Threats.map((item, i) => <SwotListItem key={`t-${i}`}>{item}</SwotListItem>)}
          </SwotList>
        </SwotQuadrant>
      </SwotGrid>
    </Card>
  );
};

export default SwotAnalysis;
</file>

<file path="frontend/src/pages/HomePage.js">
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import styled, { keyframes } from 'styled-components';
import axios from 'axios';
import { FaSearch } from 'react-icons/fa';
import IndicesBanner from '../components/Indices/IndicesBanner';
import ChartUploader from '../components/HomePage/ChartUploader';

// --- 1. ANIMATIONS (Unchanged) ---
const fadeIn = keyframes`from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); }`;
const float = keyframes`0% { transform: translate(0px, 0px) scale(1); } 33% { transform: translate(30px, -50px) scale(1.1); } 66% { transform: translate(-20px, 20px) scale(0.9); } 100% { transform: translate(0px, 0px) scale(1); }`;
const floatReverse = keyframes`0% { transform: translate(0px, 0px) scale(1); } 33% { transform: translate(-30px, 50px) scale(0.9); } 66% { transform: translate(20px, -20px) scale(1.1); } 100% { transform: translate(0px, 0px) scale(1); }`;

// --- 2. STYLED COMPONENTS ---

const HomePageContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 1rem;
  width: 100%;
  position: relative;
  overflow-x: hidden;
  @media (min-width: 768px) { padding: 2rem; }
`;

const BackgroundLayer = styled.div`position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; pointer-events: none; overflow: hidden;`;
const GlowingBlob = styled.div`position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.4; animation: ${float} 10s ease-in-out infinite;`;
const BlobOne = styled(GlowingBlob)`top: -10%; left: -10%; width: 50vw; height: 50vw; background: var(--color-primary); animation-delay: 0s;`;
const BlobTwo = styled(GlowingBlob)`bottom: -10%; right: -10%; width: 60vw; height: 60vw; background: #7c3aed; animation: ${floatReverse} 12s ease-in-out infinite;`;

const MainContent = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    width: 100%;
    margin-top: 2vh;
    z-index: 1;
    @media (min-width: 768px) { margin-top: 5vh; }
`;

const Title = styled.h1`font-size: 2.5rem; font-weight: 800; color: var(--color-text-primary); margin-bottom: 1rem; animation: ${fadeIn} 1s ease-out; letter-spacing: -1px; text-shadow: 0 4px 20px rgba(0,0,0,0.3); @media (min-width: 768px) { font-size: 4.5rem; letter-spacing: -2px; }`;
const Subtitle = styled.p`font-size: 1rem; color: var(--color-text-secondary); margin-bottom: 2rem; max-width: 600px; animation: ${fadeIn} 1.5s ease-out; padding: 0 1rem;`;

// --- NEW: SEARCH STYLES WITH DROPDOWN ---

const SearchSection = styled.div`
  width: 100%;
  max-width: 650px;
  position: relative; /* Crucial for absolute positioning of dropdown */
  animation: ${fadeIn} 1.8s ease-out;
`;

const SearchWrapper = styled.div`
  position: relative;
  width: 100%;
  display: flex;
  align-items: center;
  z-index: 10; /* Ensure search bar is above other content */
`;

const SearchInput = styled.input`
  width: 100%;
  padding: 15px 20px;
  padding-right: 60px;
  font-size: 1rem;
  color: var(--color-text-primary);
  background-color: rgba(22, 27, 34, 0.8); 
  backdrop-filter: blur(10px);
  border: 1px solid var(--color-border);
  border-radius: 50px; /* When dropdown is open, we might want to change this, but 50px is fine */
  outline: none;
  transition: all 0.3s ease;
  box-shadow: 0 4px 20px rgba(0,0,0,0.2);

  &:focus {
    border-color: var(--color-primary);
    box-shadow: 0 0 20px rgba(88, 166, 255, 0.4);
    background-color: rgba(22, 27, 34, 0.95);
  }

  @media (min-width: 768px) {
    padding: 20px 30px;
    padding-right: 70px;
    font-size: 1.2rem;
  }
`;

const SearchButton = styled.button`
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background-color: var(--color-primary);
  color: white;
  border: none;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background-color 0.2s ease, transform 0.1s ease;

  &:hover { background-color: #4FA0EE; transform: translateY(-50%) scale(1.05); }
  &:active { transform: translateY(-50%) scale(0.95); }
  @media (min-width: 768px) { width: 48px; height: 48px; right: 10px; }
`;

// --- THE NEW DROPDOWN STYLES ---
const SuggestionsList = styled.ul`
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  margin-top: 10px;
  background-color: rgba(22, 27, 34, 0.95);
  backdrop-filter: blur(12px);
  border: 1px solid var(--color-border);
  border-radius: 15px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.5);
  list-style: none;
  padding: 0;
  max-height: 300px;
  overflow-y: auto;
  z-index: 100; /* Must be on top of everything */
  
  /* Custom Scrollbar */
  &::-webkit-scrollbar { width: 6px; }
  &::-webkit-scrollbar-thumb { background: var(--color-border); border-radius: 3px; }
`;

const SuggestionItem = styled.li`
  padding: 12px 20px;
  border-bottom: 1px solid rgba(255,255,255,0.05);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: background-color 0.2s;

  &:last-child { border-bottom: none; }
  &:hover { background-color: rgba(88, 166, 255, 0.15); }
`;

const SuggestionSymbol = styled.span`
  font-weight: 700;
  color: var(--color-primary);
  font-family: 'Roboto Mono', monospace;
`;

const SuggestionName = styled.span`
  font-size: 0.9rem;
  color: var(--color-text-secondary);
  margin-left: 10px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 60%;
`;

const SuggestionExchange = styled.span`
  font-size: 0.75rem;
  background-color: var(--color-border);
  padding: 2px 6px;
  border-radius: 4px;
  color: var(--color-text-secondary);
`;

const LoadingText = styled.p`color: var(--color-primary); margin-top: 1rem; height: 20px; font-weight: 500;`;

// --- 3. THE COMPONENT ---

const HomePage = () => {
  const [query, setQuery] = useState('');
  const [suggestions, setSuggestions] = useState([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const navigate = useNavigate();
  
  // Ref to help with clicking outside to close
  const searchRef = useRef(null);

  // --- DEBOUNCE LOGIC FOR AUTOCOMPLETE ---
  useEffect(() => {
    // Don't search if query is too short
    if (query.length < 2) {
      setSuggestions([]);
      return;
    }

    // Set a delay (debounce) to avoid spamming the API while typing
    const delayDebounceFn = setTimeout(async () => {
      try {
        // Call our new fast autocomplete endpoint
        const response = await axios.get(`/api/stocks/autocomplete?query=${query}`);
        setSuggestions(response.data);
        setShowSuggestions(true);
      } catch (error) {
        console.error("Autocomplete error:", error);
      }
    }, 300); // Wait 300ms after user stops typing

    return () => clearTimeout(delayDebounceFn);
  }, [query]);


  // --- SEARCH HANDLERS ---

  const performSearch = async (searchQuery = query) => {
    // If user clicked a suggestion, use that symbol directly.
    // Otherwise use what's typed.
    const target = searchQuery.trim();

    if (target !== '') {
      setIsLoading(true);
      setError('');
      setShowSuggestions(false); // Hide dropdown
      try {
        // If it looks like a symbol (from dropdown), go direct.
        // If it's raw text, use the AI search.
        // A simple heuristic: if we clicked a suggestion, we pass the symbol.
        
        // For now, we stick to the AI search for robustness unless we are sure it is a symbol
        const response = await axios.get(`/api/stocks/search?query=${target}`);
        const symbol = response.data.symbol;
        navigate(`/stock/${symbol}`);
      } catch (err) {
        setError('Could not find a stock for that query. Please try again.');
        console.error("Search failed:", err);
      } finally {
        setIsLoading(false);
      }
    }
  };

  const handleSuggestionClick = (symbol) => {
    setQuery(symbol); // Update input box
    setSuggestions([]); // Clear suggestions
    navigate(`/stock/${symbol}`); // Go directly to the page! Faster than AI search.
  };

  const handleKeyPress = (event) => {
    if (event.key === 'Enter') {
      performSearch();
    }
  };

  // Close suggestions if clicked outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (searchRef.current && !searchRef.current.contains(event.target)) {
        setShowSuggestions(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [searchRef]);

  return (
    <HomePageContainer>
      <BackgroundLayer><BlobOne /><BlobTwo /></BackgroundLayer>
      <IndicesBanner />
      <MainContent>
        <Title>Stellar Stock Screener</Title>
        <Subtitle>Leveraging AI to provide comprehensive financial insights.</Subtitle>
        
        <SearchSection ref={searchRef}>
          <SearchWrapper>
            <SearchInput
              type="text"
              placeholder="Search for a company (e.g. Apple, Tata Motors)..."
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              onKeyPress={handleKeyPress}
              onFocus={() => query.length >= 2 && setShowSuggestions(true)}
              disabled={isLoading}
            />
            <SearchButton onClick={() => performSearch()} disabled={isLoading} aria-label="Search">
              <FaSearch size={18} />
            </SearchButton>
          </SearchWrapper>

          {/* --- THE SUGGESTIONS DROPDOWN --- */}
          {showSuggestions && suggestions.length > 0 && (
            <SuggestionsList>
              {suggestions.map((item) => (
                <SuggestionItem key={item.symbol} onClick={() => handleSuggestionClick(item.symbol)}>
                  <div style={{ display: 'flex', alignItems: 'center' }}>
                    <SuggestionSymbol>{item.symbol}</SuggestionSymbol>
                    <SuggestionName>{item.name}</SuggestionName>
                  </div>
                  <SuggestionExchange>{item.exchangeShortName}</SuggestionExchange>
                </SuggestionItem>
              ))}
            </SuggestionsList>
          )}
        </SearchSection>

        <LoadingText>{isLoading ? 'Searching with AI...' : error || ''}</LoadingText>
        <p style={{ color: 'var(--color-text-secondary)', margin: '2rem 0', fontWeight: '500' }}>OR</p>
        <ChartUploader />
      </MainContent>
    </HomePageContainer>
  );
};

export default HomePage;
</file>

<file path="nixpacks.toml">
# Tell Railway to install both Python and its default stable version of Node.js
providers = ["python", "nodejs"]

[phases.install]
# This command installs all our libraries.
cmds = ["npm --prefix frontend install", "pip install -r backend/requirements.txt"]

[phases.build]
# This command builds our React app for production.
cmds = ["npm --prefix frontend run build"]

[start]
# This command starts our Python web server.
cmd = "uvicorn backend.app.main:app --host 0.0.0.0 --port $PORT"
</file>

<file path="backend/app/services/fmp_service.py">
import os
import requests
from dotenv import load_dotenv

load_dotenv()

FMP_API_KEY = os.getenv("FMP_API_KEY")
BASE_URL = "https://financialmodelingprep.com/api/v3"

def get_company_profile(symbol: str):
    """Fetches the company profile (description, industry, etc.) from FMP."""
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    try:
        url = f"{BASE_URL}/profile/{symbol}?apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching company profile for {symbol}: {e}")
        return []

def get_quote(symbol: str):
    """Fetches the latest quote data (price, change, volume, etc.) from FMP."""
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    try:
        url = f"{BASE_URL}/quote/{symbol}?apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching quote for {symbol}: {e}")
        return []

def get_financial_statements(symbol: str, statement_type: str, period: str = "annual", limit: int = 5):
    """Fetches financial statements (income-statement, balance-sheet, cash-flow) from FMP."""
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    try:
        url = f"{BASE_URL}/{statement_type}/{symbol}?period={period}&limit={limit}&apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching {statement_type} for {symbol}: {e}")
        return []

def get_key_metrics(symbol: str, period: str = "annual", limit: int = 5):
    """Fetches key metrics (P/E, P/B, Market Cap, ROE, etc.) from FMP."""
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    try:
        url = f"{BASE_URL}/key-metrics/{symbol}?period={period}&limit={limit}&apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching key metrics for {symbol}: {e}")
        return []

def get_financial_ratios(symbol: str, period: str = "annual", limit: int = 5):
    """Fetches detailed financial ratios (current ratio, debt to equity, etc.) from FMP."""
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    try:
        url = f"{BASE_URL}/ratios/{symbol}?period={period}&limit={limit}&apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching financial ratios for {symbol}: {e}")
        return []

def get_analyst_ratings(symbol: str, limit: int = 100):
    """Fetches analyst ratings and recommendations from FMP."""
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    try:
        url = f"{BASE_URL}/rating/{symbol}?limit={limit}&apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching analyst ratings for {symbol}: {e}")
        return []

def get_shareholding_data(symbol: str, limit: int = 100):
    """Fetches the current list of institutional shareholders from FMP."""
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    try:
        url = f"{BASE_URL}/institutional-holder/{symbol}?limit={limit}&apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching shareholding data for {symbol}: {e}")
        return []
    
def get_analyst_estimates(symbol: str, limit: int = 1):
    """Fetches analyst earnings estimates for the upcoming quarter from FMP."""
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    try:
        url = f"{BASE_URL}/analyst-estimates/{symbol}?limit={limit}&apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()[0] if response.json() else {}
    except requests.exceptions.RequestException as e:
        print(f"Error fetching analyst estimates for {symbol}: {e}")
        return {}

def get_price_target_consensus(symbol: str):
    """Fetches the price target consensus (high, low, average) from FMP."""
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    try:
        url = f"{BASE_URL}/price-target-consensus/{symbol}?apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()[0] if response.json() else {}
    except requests.exceptions.RequestException as e:
        print(f"Error fetching price target consensus for {symbol}: {e}")
        return {}

def get_technical_indicators(symbol: str, period: int = 14):
    """Fetches a wide range of daily technical indicators from FMP."""
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    try:
        url = f"{BASE_URL}/technical_indicator/daily/{symbol}?period={period}&apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()[0] if response.json() else {}
    except requests.exceptions.RequestException as e:
        print(f"Error fetching technical indicators for {symbol}: {e}")
        return {}

def get_historical_institutional_ownership(symbol: str, limit: int = 8):
    """Fetches the quarterly historical ownership data for institutional investors."""
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    try:
        url = f"{BASE_URL}/institutional-ownership/symbol-ownership?symbol={symbol}&include_current_quarter=true&limit={limit}&apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching historical institutional ownership for {symbol}: {e}")
        return []

def get_peers_with_metrics(symbols: list):
    """
    This is now a utility function. It takes a LIST of symbols
    and fetches key metrics for all of them in a single, efficient batch call.
    """
    if not FMP_API_KEY:
        return {"error": "FMP API key not found."}
    if not symbols:
        return []
        
    try:
        # The FMP API allows for comma-separated symbols for high efficiency.
        symbols_str = ",".join(symbols)
        
        # We use the key-metrics-ttm endpoint to get the latest trailing-twelve-months data.
        metrics_url = f"{BASE_URL}/key-metrics-ttm/{symbols_str}?apikey={FMP_API_KEY}"
        metrics_response = requests.get(metrics_url)
        metrics_response.raise_for_status()
        
        return metrics_response.json()

    except requests.exceptions.RequestException as e:
        print(f"Error fetching peers metrics for symbols {symbols_str}: {e}")
        return []

# ... (keep all existing functions)

def search_ticker(query: str, limit: int = 10):
    """
    Searches for a stock ticker based on a query string.
    Used for the frontend autocomplete dropdown.
    """
    if not FMP_API_KEY:
        return []
    try:
        # The search endpoint is very fast and lightweight
        url = f"{BASE_URL}/search?query={query}&limit={limit}&apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error searching for ticker '{query}': {e}")
        return []

def get_stock_news(symbol: str, limit: int = 10):
    """
    Fetches specific stock news from FMP and normalizes it to match the NewsAPI format.
    """
    if not FMP_API_KEY:
        return []
    try:
        url = f"{BASE_URL}/stock_news?tickers={symbol}&limit={limit}&apikey={FMP_API_KEY}"
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()
        
        # Normalize FMP data to match NewsAPI format
        normalized_news = []
        for item in data:
            normalized_news.append({
                "title": item.get('title'),
                "url": item.get('url'),
                "publishedAt": item.get('publishedDate'), # FMP uses publishedDate
                "source": {"name": item.get('site')},     # FMP uses site
                "description": item.get('text'),
                "urlToImage": item.get('image')
            })
        return normalized_news
    except requests.exceptions.RequestException as e:
        print(f"Error fetching FMP news for {symbol}: {e}")
        return []
</file>

<file path="backend/requirements.txt">
annotated-doc==0.0.3
annotated-types==0.7.0
anyio==4.11.0
beautifulsoup4==4.14.2
cachetools==6.2.1
certifi==2025.10.5
cffi==2.0.0
charset-normalizer==3.4.4
click==8.3.0
colorama==0.4.6
curl_cffi==0.13.0
fastapi==0.121.0
frozendict==2.4.6
google-ai-generativelanguage==0.6.15
google-api-core==2.28.1
google-api-python-client==2.187.0
google-auth==2.43.0
google-auth-httplib2==0.2.1
google-generativeai==0.8.5
googleapis-common-protos==1.72.0
grpcio==1.76.0
grpcio-status==1.71.2
h11==0.16.0
httplib2==0.31.0
httptools==0.7.1
idna==3.11
llvmlite==0.44.0
multitasking==0.0.12
numba==0.61.2
numpy==2.2.6
pandas==2.3.3
pandas-ta==0.4.71b0
peewee==3.18.3
platformdirs==4.5.0
proto-plus==1.26.1
protobuf==5.29.5
pyasn1==0.6.1
pyasn1_modules==0.4.2
pycparser==2.23
pydantic==2.12.4
pydantic_core==2.41.5
pyparsing==3.2.5
python-dateutil==2.9.0.post0
python-dotenv==1.2.1
python-multipart==0.0.20
pytz==2025.2
PyYAML==6.0.3
requests==2.32.5
rsa==4.9.1
six==1.17.0
sniffio==1.3.1
soupsieve==2.8
starlette==0.49.3
tqdm==4.67.1
typing-inspection==0.4.2
typing_extensions==4.15.0
tzdata==2025.2
uritemplate==4.2.0
urllib3==2.5.0
uvicorn==0.38.0
watchfiles==1.1.1
websockets==15.0.1
yfinance==0.2.66
</file>

<file path="backend/app/services/yahoo_service.py">
import yfinance as yf
import pandas as pd
import pandas_ta as ta
import re

def get_historical_data(symbol: str, period: str = "1y", interval: str = "1d"):
    """
    Fetches historical stock price data from Yahoo Finance.
    Includes optimized period mapping to prevent API errors for intraday data.
    """
    try:
        # --- SMART PERIOD MAPPING (TUNED) ---
        # Yahoo requires very specific periods for intraday intervals.
        adjusted_period = period 
        
        if interval == "1m":
            adjusted_period = "5d"  # Max 7 days, 5 is safer
        elif interval in ["2m", "5m", "15m", "30m", "90m"]:
            adjusted_period = "5d"  # 1mo often fails. 5d is reliable for recent technicals.
        elif interval == "60m" or interval == "1h":
            adjusted_period = "1mo" # 1mo is reliable for hourly.
        elif interval in ["1d", "5d", "1wk", "1mo", "3mo"]:
            adjusted_period = "1y"  # Standard for daily+

        ticker = yf.Ticker(symbol)
        
        # Fetch data
        hist = ticker.history(period=adjusted_period, interval=interval)
        
        if hist.empty:
            print(f"Warning: No historical data found for {symbol} (Interval: {interval}, Period: {adjusted_period})")
            return None
        
        # Ensure lowercase columns
        hist.columns = [col.lower() for col in hist.columns]
        return hist

    except Exception as e:
        print(f"Error fetching historical data for {symbol}: {e}")
        return None

def calculate_technical_indicators(df: pd.DataFrame):
    """
    Calculates a set of technical indicators from a DataFrame of historical price data.
    """
    if df is None or df.empty:
        return {}

    try:
        # Use pandas_ta to calculate indicators
        df.ta.rsi(length=14, append=True)
        df.ta.macd(fast=12, slow=26, signal=9, append=True)
        df.ta.stoch(k=14, d=3, smooth_k=3, append=True)
        df.ta.adx(length=14, append=True)
        df.ta.atr(length=14, append=True)
        df.ta.willr(length=14, append=True)
        df.ta.bbands(length=20, std=2, append=True)
        
        # Get the very last row (most recent data point)
        latest_indicators = df.iloc[-1]
        
        # We also grab the previous row to determine short-term trend direction if needed
        prev_indicators = df.iloc[-2] if len(df) > 1 else latest_indicators

        return {
            "rsi": latest_indicators.get('RSI_14'),
            "macd": latest_indicators.get('MACD_12_26_9'),
            "macdsignal": latest_indicators.get('MACDs_12_26_9'),
            "stochasticsk": latest_indicators.get('STOCHk_14_3_3'),
            "adx": latest_indicators.get('ADX_14'),
            "atr": latest_indicators.get('ATRr_14'),
            "williamsr": latest_indicators.get('WILLR_14'),
            "bollingerBands": {
                "upperBand": latest_indicators.get('BBU_20_2.0'),
                "middleBand": latest_indicators.get('BBM_20_2.0'),
                "lowerBand": latest_indicators.get('BBL_20_2.0'),
            },
            # Helpful for the AI to know the immediate direction
            "price_action": {
                "close": latest_indicators.get('close'),
                "trend": "UP" if latest_indicators.get('close') > prev_indicators.get('close') else "DOWN"
            }
        }
    except Exception as e:
        print(f"Error calculating technical indicators: {e}")
        return {}

def get_analyst_recommendations(symbol: str):
    """Fetches analyst recommendation data (strong buy, buy, hold, etc.)."""
    try:
        ticker = yf.Ticker(symbol)
        recommendations = ticker.recommendations
        if recommendations is None or recommendations.empty:
            return []
        
        latest_summary = recommendations.iloc[-1]
        
        return [{
            "ratingStrongBuy": int(latest_summary.get('strong buy', 0)),
            "ratingBuy": int(latest_summary.get('buy', 0)),
            "ratingHold": int(latest_summary.get('hold', 0)),
            "ratingSell": int(latest_summary.get('sell', 0)),
            "ratingStrongSell": int(latest_summary.get('strong sell', 0)),
        }]
    except Exception as e:
        return []

def get_price_target_data(symbol: str):
    """Fetches price target data (high, low, average)."""
    try:
        ticker = yf.Ticker(symbol)
        analysis = ticker.info
        
        if not analysis or 'targetMeanPrice' not in analysis or analysis.get('targetMeanPrice') is None:
            return {}
            
        return {
            "targetHigh": analysis.get('targetHighPrice'),
            "targetLow": analysis.get('targetLowPrice'),
            "targetConsensus": analysis.get('targetMeanPrice'),
        }
    except Exception as e:
        return {}

def get_key_fundamentals(symbol: str):
    """
    Fetches essential metrics directly from Yahoo Finance's reliable .info dictionary.
    """
    try:
        ticker = yf.Ticker(symbol)
        info = ticker.info

        def get_float(key):
            val = info.get(key)
            return val if val is not None and isinstance(val, (int, float)) else None

        trailing_eps = get_float('trailingEps')
        market_price = get_float('regularMarketPrice') or get_float('previousClose')
        
        earnings_yield = None
        if trailing_eps is not None and market_price is not None and market_price != 0:
            earnings_yield = trailing_eps / market_price
        
        roe = get_float('returnOnEquity')
        
        return {
            "symbol": symbol,
            "peRatioTTM": get_float('trailingPE'),
            "earningsYieldTTM": earnings_yield,
            "returnOnCapitalEmployedTTM": roe,
            "marketCap": get_float('marketCap'),
            "revenueGrowth": get_float('revenueGrowth'),
            "grossMargins": get_float('grossMargins'),
            "dividendYieldTTM": get_float('dividendYield'),
            "epsTTM": trailing_eps,
            "netIncomePerShareTTM": trailing_eps,
            "revenuePerShareTTM": get_float('revenuePerShare'),
            "sharesOutstanding": get_float('sharesOutstanding'),
            "beta": get_float('beta'),
            "fullTimeEmployees": info.get('fullTimeEmployees')
        }
    except Exception as e:
        print(f"Error fetching yfinance key fundamentals for {symbol}: {e}")
        return {}

def _parse_yfinance_financials(df):
    """Internal helper to transpose and clean Yahoo Finance DataFrame."""
    if df is None or df.empty:
        return []
    
    try:
        df_t = df.transpose()
        df_t.reset_index(inplace=True)
        date_col_name = df_t.columns[0]
        df_t.rename(columns={date_col_name: 'date'}, inplace=True)
        df_t['date'] = df_t['date'].astype(str).str.slice(0, 10)
        records = df_t.to_dict('records')
        
        mapped_records = []
        for record in records:
            new_record = {'date': record['date']}
            
            def get_val(keys):
                for k in keys:
                    if k in record and pd.notna(record[k]):
                        return float(record[k])
                return 0.0

            new_record['netIncome'] = get_val(['Net Income', 'NetIncome', 'Net Income Common Stockholders'])
            new_record['revenue'] = get_val(['Total Revenue', 'TotalRevenue', 'Operating Revenue'])
            new_record['grossProfit'] = get_val(['Gross Profit', 'GrossProfit'])
            new_record['eps'] = get_val(['Basic EPS', 'BasicEPS'])
            new_record['weightedAverageShsOut'] = get_val(['Basic Average Shares', 'Average Diluted Shares'])
            new_record['totalAssets'] = get_val(['Total Assets', 'TotalAssets'])
            new_record['longTermDebt'] = get_val(['Long Term Debt', 'LongTermDebt'])
            new_record['totalCurrentAssets'] = get_val(['Total Current Assets', 'Current Assets'])
            new_record['totalCurrentLiabilities'] = get_val(['Total Current Liabilities', 'Current Liabilities'])
            new_record['totalStockholdersEquity'] = get_val(['Stockholders Equity', 'Total Stockholder Equity'])
            new_record['operatingCashFlow'] = get_val(['Operating Cash Flow', 'OperatingCashFlow'])
            new_record['dividendsPaid'] = get_val(['Cash Dividends Paid', 'CashDividendsPaid'])
            new_record['calendarYear'] = new_record['date'][:4]
            
            mapped_records.append(new_record)
        return mapped_records

    except Exception as e:
        print(f"Error parsing yfinance financials: {e}")
        return []

def get_historical_financials(symbol: str):
    """Fetches ANNUAL historical financial statements."""
    try:
        ticker = yf.Ticker(symbol)
        return {
            "income": _parse_yfinance_financials(ticker.financials),
            "balance": _parse_yfinance_financials(ticker.balance_sheet),
            "cash_flow": _parse_yfinance_financials(ticker.cashflow),
        }
    except Exception as e:
        return {"income": [], "balance": [], "cash_flow": []}

def get_quarterly_financials(symbol: str):
    """Fetches QUARTERLY historical financial statements."""
    try:
        ticker = yf.Ticker(symbol)
        return {
            "income": _parse_yfinance_financials(ticker.quarterly_financials),
            "balance": _parse_yfinance_financials(ticker.quarterly_balance_sheet),
            "cash_flow": _parse_yfinance_financials(ticker.quarterly_cashflow),
        }
    except Exception as e:
        return {"income": [], "balance": [], "cash_flow": []}

def get_shareholding_summary(symbol: str):
    """
    Fetches shareholding breakdown using a robust 'fuzzy search' strategy.
    Works for US and Indian stocks.
    """
    try:
        ticker = yf.Ticker(symbol)
        insider_raw = 0.0
        institution_raw = 0.0
        data_found = False

        # Strategy 1: Check ticker.info
        info = ticker.info
        if info:
            if info.get('heldPercentInsiders') is not None:
                insider_raw = info.get('heldPercentInsiders')
                data_found = True
            if info.get('heldPercentInstitutions') is not None:
                institution_raw = info.get('heldPercentInstitutions')
                data_found = True

        # Strategy 2: Check major_holders table
        if not data_found:
            major_holders = ticker.major_holders
            if major_holders is not None and not major_holders.empty:
                for i in range(len(major_holders)):
                    try:
                        row = major_holders.iloc[i].astype(str).values.tolist()
                        row_text = " ".join(row).lower()
                        match = re.search(r'(\d+(\.\d+)?)%', row_text)
                        if match:
                            val = float(match.group(1)) / 100.0
                            if 'insider' in row_text:
                                insider_raw = val
                                data_found = True
                            elif 'institution' in row_text:
                                institution_raw = val
                                data_found = True
                    except: continue

        if not data_found:
            return {}

        promoter_percent = insider_raw * 100
        institutional_percent = institution_raw * 100
        public_percent = max(0, 100 - promoter_percent - institutional_percent)
        
        return {
            "promoter": promoter_percent,
            "fii": institutional_percent * 0.6, # Proxy
            "dii": institutional_percent * 0.4, # Proxy
            "public": public_percent,
        }
    except Exception as e:
        print(f"Error fetching yfinance shareholding summary for {symbol}: {e}")
        return {}

def get_company_info(symbol: str):
    """Fetches company info."""
    try:
        ticker = yf.Ticker(symbol)
        info = ticker.info
        return info if info and 'symbol' in info else {}
    except Exception: return {}
</file>

<file path="Dockerfile">
# Stage 1: Build the React Frontend
# This stage correctly builds our static frontend files.
FROM node:18-alpine AS builder
WORKDIR /app/frontend
COPY frontend/package*.json ./
RUN npm install
COPY frontend/ ./
RUN npm run build

# Stage 2: Build the Final Python Application Image
# This stage takes the built frontend and combines it with our Python backend.
FROM python:3.12-slim

# This is a best-practice environment variable for Python in Docker.
ENV PYTHONUNBUFFERED 1

# Set the working directory for the application.
WORKDIR /app

# Copy the Python dependency list first.
# This optimizes Docker's caching, so dependencies are only re-installed if this file changes.
COPY ./backend/requirements.txt .

# Install all Python dependencies from the requirements file.
RUN pip install --no-cache-dir --upgrade pip -r requirements.txt

# Now, copy all of your application code into the image.
COPY ./backend ./backend

# --- THIS IS THE CORRECTED LINE ---
# Copy the built frontend files from the 'builder' stage into the correct location.
COPY --from=builder /app/frontend/build ./frontend/build

# Set the final command to run the Uvicorn server.
CMD ["python", "-m", "uvicorn", "backend.app.main:app", "--host", "0.0.0.0", "--port", "8080"]
</file>

<file path="frontend/src/components/Fundamentals/Fundamentals.js">
import React, { useState, useEffect, useMemo } from 'react';
import styled, { keyframes } from 'styled-components';
import Card from '../common/Card';
import axios from 'axios';
import { NestedTabs, NestedTabPanel } from '../common/Tabs/NestedTabs';
import DarvasScan from './DarvasScan';
import BenjaminGrahamScan from './BenjaminGrahamScan';
import FundamentalConclusion from './FundamentalConclusion';

// --- Styled Components & Animations ---

const fadeIn = keyframes`
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
`;

const SectionContainer = styled.div`
  animation: ${fadeIn} 0.5s ease-out;
`;

const SectionTitle = styled.h3`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 1.5rem;
  color: var(--color-text-primary);
`;

const PiotroskiGrid = styled.div`
  display: grid;
  grid-template-columns: 1fr 2fr;
  gap: 2rem;
  align-items: center;
  @media (max-width: 768px) {
    grid-template-columns: 1fr;
  }
`;

const ScoreCard = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 2rem;
  background-color: var(--color-background);
  border-radius: 50%;
  width: 180px;
  height: 180px;
  border: 4px solid ${({ scoreColor }) => scoreColor};
  margin: 0 auto;
`;

const ScoreValue = styled.span`
  font-size: 4rem;
  font-weight: 800;
  color: ${({ scoreColor }) => scoreColor};
`;

const ScoreLabel = styled.span`
  font-size: 1rem;
  font-weight: 500;
  color: var(--color-text-secondary);
`;

const CriteriaList = styled.ul`
  list-style-type: none;
  padding-left: 0;
`;

const CriteriaListItem = styled.li`
  margin-bottom: 0.75rem;
  color: var(--color-text-primary);
  display: flex;
  align-items: center;
  &::before {
    content: '✓';
    color: var(--color-success);
    margin-right: 12px;
    font-size: 1.2rem;
    font-weight: bold;
  }
`;

// --- Generic Table/Grid Styles ---
const AssessmentTable = styled.div`
  display: grid;
  gap: 1px;
  background-color: var(--color-border);
  border: 1px solid var(--color-border);
  border-radius: 8px;
  overflow: hidden;

  /* Mobile: Stack vertically (1 column) */
  grid-template-columns: 100%;

  /* Desktop: Side-by-side (2 columns) */
  @media (min-width: 768px) {
    grid-template-columns: 1fr 3fr;
  }

  & > div {
    background-color: var(--color-secondary);
    padding: 1rem;
    line-height: 1.5;
  }

  /* Special styling for headers to look good when stacked */
  & > .header {
    font-weight: 600;
    color: var(--color-primary); /* Make headers pop on mobile */
    background-color: var(--color-background);
    
    /* On mobile, headers might look odd in the grid flow, 
       but we'll keep them for context or you can hide them with: 
       @media (max-width: 768px) { display: none; } 
       if you prefer a cleaner look. For now, color distinction is enough. */
  }
`;

// --- NEW RESPONSIVE STYLES ---

// 1. The Container for the rows
const CanslimContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: 1px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid var(--color-border);

  /* On Mobile: Remove border and add gap for card look */
  @media (max-width: 768px) {
    border: none;
    gap: 1rem;
    overflow: visible;
    border-radius: 0;
  }
`;

// 2. The Header Row (Visible on Desktop, Hidden on Mobile)
const DesktopHeader = styled.div`
  display: grid;
  grid-template-columns: 1fr 3fr 1fr;
  background-color: var(--color-background);
  padding: 1rem;
  font-weight: 600;
  color: var(--color-text-secondary);
  border-bottom: 1px solid var(--color-border);

  @media (max-width: 768px) {
    display: none; /* Hide on mobile */
  }
`;

// 3. The Data Row (Table Row on Desktop, Card on Mobile)
const CanslimRow = styled.div`
  display: grid;
  grid-template-columns: 1fr 3fr 1fr;
  background-color: var(--color-secondary);
  
  /* Desktop: Align items center */
  & > div {
    padding: 1rem;
    display: flex;
    align-items: center;
  }

  /* --- MOBILE TRANSFORMATION --- */
  @media (max-width: 768px) {
    display: flex;
    flex-direction: column;
    background-color: var(--color-secondary);
    border: 1px solid var(--color-border);
    border-radius: 12px;
    padding: 0; /* Reset padding for internal layout */
    position: relative;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);

    /* Criteria (Header of the Card) */
    & > div:nth-child(1) {
      font-weight: 700;
      color: var(--color-primary);
      border-bottom: 1px solid var(--color-border);
      background-color: rgba(88, 166, 255, 0.05);
      padding: 1rem;
    }

    /* Assessment (Body of the Card) */
    & > div:nth-child(2) {
      color: var(--color-text-secondary);
      line-height: 1.6;
      padding: 1rem;
    }

    /* Result (Footer Badge of the Card) */
    & > div:nth-child(3) {
      position: absolute;
      top: 1rem;
      right: 1rem;
      padding: 0;
      font-size: 0.9rem;
      background: none;
    }
  }
`;

// 4. The Result Text Colorer
const ResultText = styled.span`
  font-weight: 800;
  text-transform: uppercase;
  color: ${({ result }) => {
    if (!result) return 'var(--color-text-secondary)';
    const res = result.toLowerCase();
    if (res.includes('pass') || res.includes('yes')) return 'var(--color-success)';
    if (res.includes('fail') || res.includes('no')) return 'var(--color-danger)';
    return 'var(--color-text-secondary)';
  }};
`;


const Loader = styled.div`
  color: var(--color-primary);
  animation: ${fadeIn} 0.5s ease-in;
  height: 150px;
  display: flex;
  align-items: center;
  justify-content: center;
`;

// --- Helper to parse "key: value" or "bullet point" formats if table parsing fails ---
const parseTextFallback = (text) => {
    if (!text) return [];
    const lines = text.split('\n');
    const items = [];
    lines.forEach(line => {
        const clean = line.trim();
        // Look for "Key: Value" pattern or "- Value"
        if (clean.includes(':')) {
            const parts = clean.split(':');
            items.push([parts[0].replace(/^[*-]\s*/, '').trim(), parts.slice(1).join(':').trim(), '']);
        } else if (clean.startsWith('-') || clean.startsWith('*')) {
             items.push(['Point', clean.replace(/^[*-]\s*/, '').trim(), '']);
        }
    });
    return items;
};


// --- The Final Master Fundamentals Component ---

const Fundamentals = ({
  symbol,
  profile,
  quote,
  keyMetrics,
  piotroskiData,
  darvasScanData,
  grahamScanData,
  quarterlyEarnings,
  annualEarnings,
  shareholding,
  delay,
  philosophyAssessment,
  canslimAssessment,
  conclusion,
  isLoadingPhilosophy,
  isLoadingCanslim,
  isLoadingConclusion
}) => {

  // --- Data Processing for Piotroski Score ---
  const { score, criteria } = piotroskiData || {};
  const getScoreColor = () => {
    if (score >= 7) return 'var(--color-success)';
    if (score >= 4) return '#EDBB5A';
    return 'var(--color-danger)';
  };
  const scoreColor = getScoreColor();
  
  // --- ROBUST PARSER FOR VALUE INVESTING ---
  const parsedPhilosophy = useMemo(() => {
    if (!philosophyAssessment || typeof philosophyAssessment !== 'string') return [];
    
    // 1. Try Table Parsing
    const tableRows = philosophyAssessment.split('\n')
      .filter(line => line.includes('|'))
      .map(row => row.split('|').map(c => c.trim()))
      .filter(r => r.length > 2 && !r[1].includes('---') && !r[1].toLowerCase().includes('formula'));
    
    if (tableRows.length > 0) return tableRows;

    // 2. Fallback to Text Parsing
    return parseTextFallback(philosophyAssessment);
  }, [philosophyAssessment]);
  
  // --- ROBUST PARSER FOR CANSLIM ---
  const parsedCanslim = useMemo(() => {
    if (!canslimAssessment || typeof canslimAssessment !== 'string') return [];
    
    // 1. Try Table Parsing
    const tableRows = canslimAssessment.split('\n')
      .filter(line => line.includes('|'))
      .map(row => row.split('|').map(c => c.trim()))
      .filter(r => r.length > 3 && !r[1].includes('---') && !r[1].toLowerCase().includes('criteria'));
      
    if (tableRows.length > 0) return tableRows;

    // 2. Fallback to Text Parsing
    return parseTextFallback(canslimAssessment);
  }, [canslimAssessment]);

  return (
    <Card>
      <NestedTabs>
        
        <NestedTabPanel label="Conclusion">
          <SectionContainer>
            {isLoadingConclusion ? (
              <Loader>Synthesizing all fundamental data...</Loader>
            ) : (
              <FundamentalConclusion conclusionData={conclusion} />
            )}
          </SectionContainer>
        </NestedTabPanel>

        <NestedTabPanel label="Graham Scan">
          <SectionContainer>
            <BenjaminGrahamScan scanData={grahamScanData} />
          </SectionContainer>
        </NestedTabPanel>
        
        <NestedTabPanel label="Piotroski Scan">
          <SectionContainer>
            <SectionTitle>Piotroski F-Score</SectionTitle>
            {piotroskiData && piotroskiData.score !== undefined ? (
              <PiotroskiGrid>
                <ScoreCard scoreColor={scoreColor}>
                  <ScoreValue scoreColor={scoreColor}>{score}</ScoreValue>
                  <ScoreLabel>/ 9</ScoreLabel>
                </ScoreCard>
                <div>
                  <p style={{ color: 'var(--color-text-secondary)', marginBottom: '1.5rem', lineHeight: 1.6 }}>
                    The F-Score reflects financial strength based on 9 criteria. A high score (7-9) suggests a healthy company.
                  </p>
                  <CriteriaList>
                    {criteria && criteria.map((item, index) => ( <CriteriaListItem key={index}>{item}</CriteriaListItem> ))}
                  </CriteriaList>
                </div>
              </PiotroskiGrid>
            ) : <p>Piotroski F-Score data not available for this stock.</p>}
          </SectionContainer>
        </NestedTabPanel>

        <NestedTabPanel label="CANSLIM">
          <SectionContainer>
            <SectionTitle>CANSLIM Analysis (William J. O'Neil)</SectionTitle>
            {isLoadingCanslim ? ( 
              <Loader>Generating CANSLIM assessment...</Loader> 
            ) : (
              parsedCanslim.length > 0 ? (
                <CanslimContainer>
                  {/* Header only shows on Desktop */}
                  <DesktopHeader>
                    <div>Criteria</div>
                    <div>Assessment</div>
                    <div>Result</div>
                  </DesktopHeader>
                  
                  {/* Rows map to Cards on Mobile */}
                  {parsedCanslim.map((row, rowIndex) => (
                    <CanslimRow key={rowIndex}>
                      {/* Criteria Name */}
                      <div>{row[0] === 'Point' ? '' : row[1]}</div>
                      
                      {/* Assessment Text */}
                      <div>{row[0] === 'Point' ? row[1] : row[2]}</div>
                      
                      {/* Result (Pass/Fail) */}
                      <div>
                        <ResultText result={row[3] || row[2]}>
                            {row[3] || ''}
                        </ResultText>
                      </div>
                    </CanslimRow>
                  ))}
                </CanslimContainer>
              ) : <p style={{ whiteSpace: 'pre-wrap', lineHeight: 1.6 }}>{canslimAssessment || "Data insufficient for CANSLIM analysis."}</p>
            )}
          </SectionContainer>
        </NestedTabPanel>

        <NestedTabPanel label="Darvas Scan">
            <SectionContainer>
                <SectionTitle>Darvas Box Scan</SectionTitle>
                <p style={{ color: 'var(--color-text-secondary)', lineHeight: 1.6, marginTop: '-1rem', marginBottom: '1.5rem' }}>
                  A momentum strategy that identifies stocks consolidating in a narrow price range ("box") near their 52-week high.
                </p>
                <DarvasScan scanData={darvasScanData} currency={profile?.currency} />
            </SectionContainer>
        </NestedTabPanel>

        <NestedTabPanel label="Value Investing">
            <SectionContainer>
                <SectionTitle>Investment Philosophy Summary</SectionTitle>
                {isLoadingPhilosophy ? ( <Loader>Generating AI analysis summary...</Loader> ) : (
                  parsedPhilosophy.length > 0 ? (
                    <AssessmentTable>
                      <div className="header">Formula</div>
                      <div className="header">Assessment</div>
                      {parsedPhilosophy.map((row, rowIndex) => (
                        <React.Fragment key={rowIndex}>
                          <div>{row[0] === 'Point' ? '' : row[1]}</div>
                          <div>{row[0] === 'Point' ? row[1] : row[2]}</div>
                        </React.Fragment>
                      ))}
                    </AssessmentTable>
                  ) : <p style={{ whiteSpace: 'pre-wrap', lineHeight: 1.6 }}>{philosophyAssessment || "Data insufficient for Investment Philosophy analysis."}</p>
                )}
            </SectionContainer>
        </NestedTabPanel>
        
      </NestedTabs>
    </Card>
  );
};

export default Fundamentals;
</file>

<file path="backend/app/services/gemini_service.py">
import os
import google.generativeai as genai
from dotenv import load_dotenv
import itertools

load_dotenv()

# --- THE API KEY ROTATOR (Essential for Stability) ---
try:
    GEMINI_API_KEYS_STR = os.getenv("GEMINI_API_KEYS")
    if not GEMINI_API_KEYS_STR:
        raise ValueError("GEMINI_API_KEYS not found in .env file. Please add it as a comma-separated list.")
    
    GEMINI_API_KEYS = [key.strip() for key in GEMINI_API_KEYS_STR.split(',')]
    
    key_cycler = itertools.cycle(GEMINI_API_KEYS)
    print(f"Successfully loaded and initialized rotator for {len(GEMINI_API_KEYS)} Gemini API keys.")

except (ValueError, AttributeError) as e:
    print(f"CRITICAL ERROR: Could not load Gemini API keys. AI features will fail. Error: {e}")
    GEMINI_API_KEYS = []
    key_cycler = None

def configure_gemini_for_request():
    """Configures the genai library with the next available key from the pool."""
    if not key_cycler:
        raise ValueError("No Gemini API keys are configured or available.")
    
    api_key = next(key_cycler)
    genai.configure(api_key=api_key)


# --- TEXT ANALYSIS FUNCTIONS ---

def get_ticker_from_query(query: str):
    """Uses the Gemini model with a rotated API key to find a stock ticker."""
    try:
        configure_gemini_for_request()
        model = genai.GenerativeModel('gemini-2.5-flash')
        prompt = f"""Analyze the following user query: "{query}". Return ONLY the official stock ticker symbol (e.g., "AAPL" for Apple, "RELIANCE.NS" for Reliance Industries). If a clear ticker cannot be found, return the text "NOT_FOUND"."""
        response = model.generate_content(prompt)
        return response.text.strip().replace("`", "").upper()
    except Exception as e:
        print(f"An error occurred in get_ticker_from_query: {e}")
        return "ERROR"

def generate_swot_analysis(company_name: str, description: str, news_headlines: list):
    """Generates a SWOT analysis with a rotated API key."""
    try:
        configure_gemini_for_request()
        model = genai.GenerativeModel('gemini-2.5-flash')
        news_string = "\n- ".join(news_headlines)
        prompt = f"""Generate a 4-section SWOT analysis for {company_name}. Use the following data for context. Structure the output with clear headers for Strengths, Weaknesses, Opportunities, and Threats, each followed by bullet points.\n\n**Company Description:**\n{description}\n\n**Recent News Headlines:**\n- {news_string}"""
        response = model.generate_content(prompt)
        return response.text.strip()
    except Exception as e:
        print(f"An error occurred in generate_swot_analysis: {e}")
        return "Could not generate SWOT analysis."

def generate_forecast_analysis(company_name: str, analyst_ratings: list, price_target: dict, key_stats: dict, news_headlines: list):
    """Generates a forecast analysis with a rotated API key."""
    try:
        configure_gemini_for_request()
        model = genai.GenerativeModel('gemini-2.5-flash')
        ratings_summary = "\n".join([f"- {r.get('ratingStrongBuy', 0)} Strong Buy, {r.get('ratingBuy', 0)} Buy, {r.get('ratingHold', 0)} Hold, {r.get('ratingSell', 0)} Sell, {r.get('ratingStrongSell', 0)} Strong Sell" for r in analyst_ratings[:1]])
        news_string = "\n- ".join(news_headlines)
        prompt = f"""Act as a professional financial analyst. For {company_name}, write a two-paragraph summary of the analyst forecast based on the following data:\n- **Analyst Ratings:** {ratings_summary}\n- **Price Target:** High ${price_target.get('targetHigh')}, Average ${price_target.get('targetConsensus')}, Low ${price_target.get('targetLow')}\n- **Recent News:**\n- {news_string}"""
        response = model.generate_content(prompt)
        return response.text.strip()
    except Exception as e:
        print(f"An error occurred in generate_forecast_analysis: {e}")
        return "Could not generate AI forecast analysis."

def generate_investment_philosophy_assessment(company_name: str, key_metrics: dict):
    """Generates a philosophy assessment with a rotated API key."""
    try:
        configure_gemini_for_request()
        model = genai.GenerativeModel('gemini-2.5-flash')
        pe_ratio = key_metrics.get('peRatioTTM')
        earnings_yield = key_metrics.get('earningsYieldTTM')
        roc = key_metrics.get('returnOnCapitalEmployedTTM')
        if pe_ratio is None or earnings_yield is None or roc is None:
            return "Could not generate assessment due to missing P/E, ROC, or Earnings Yield."
        data_summary = f"- Price to Earnings (P/E) Ratio: {pe_ratio if isinstance(pe_ratio, str) else f'{pe_ratio:.2f}'}\n- Earnings Yield (E/P): {earnings_yield if isinstance(earnings_yield, str) else f'{earnings_yield:.4f}'}\n- Return on Capital (ROC): {roc if isinstance(roc, str) else f'{roc:.4f}'}"
        prompt = f"""Act as an analyst. For {company_name}, assess it against 3 philosophies (Magic Formula, Warren Buffett, Coffee Can) based on these metrics:\n{data_summary}\nOutput a clean, 2-column Markdown table with headers "Formula" and "Assessment", naturally incorporating metric values in the text."""
        response = model.generate_content(prompt)
        return response.text.strip()
    except Exception as e:
        print(f"An error occurred in generate_investment_philosophy_assessment: {e}")
        return "Could not generate AI assessment."

def generate_canslim_assessment(company_name: str, quote: dict, quarterly_earnings: list, annual_earnings: list, institutional_holders: int):
    """Generates a CANSLIM assessment with a rotated API key."""
    try:
        configure_gemini_for_request()
        model = genai.GenerativeModel('gemini-2.5-flash')
        
        c_growth, a_growth, is_new_high, is_high_demand = "N/A", "N/A", "No", "No"
        if len(quarterly_earnings) > 4:
            latest_q_eps = quarterly_earnings[0].get('eps', 0)
            previous_q_eps = quarterly_earnings[4].get('eps', 0)
            if previous_q_eps not in [0, None]: c_growth = f"{((latest_q_eps - previous_q_eps) / abs(previous_q_eps)) * 100:.2f}% (YoY)"
        if len(annual_earnings) >= 2:
            latest_y_eps = annual_earnings[0].get('eps', 0)
            previous_y_eps = annual_earnings[1].get('eps', 0)
            if previous_y_eps not in [0, None]: a_growth = f"{((latest_y_eps - previous_y_eps) / abs(previous_y_eps)) * 100:.2f}%"
        price = quote.get('price'); year_high = quote.get('yearHigh')
        if price and year_high:
            percent_from_high = ((price - year_high) / year_high) * 100
            if percent_from_high >= -15: is_new_high = f"Yes, within {abs(percent_from_high):.2f}% of 52-week high"
        volume = quote.get('volume'); avg_volume = quote.get('avgVolume')
        if volume and avg_volume and volume > avg_volume:
            is_high_demand = f"Yes, volume is {((volume - avg_volume) / avg_volume) * 100:.2f}% above average"
        i_sponsorship = f"{institutional_holders} institutions hold this stock."

        prompt = f"""Act as an analyst applying CANSLIM to {company_name}. Based *only* on the data, create a 7-point checklist. Output a 3-column Markdown table: "Criteria", "Assessment", "Result" (Pass/Fail/Neutral). DATA: C={c_growth}, A={a_growth}, N={is_new_high}, S={is_high_demand}, L=Infer leadership, I={i_sponsorship}, M=Infer market direction."""
        
        response = model.generate_content(prompt)
        return response.text.strip()
    except Exception as e:
        print(f"An error occurred in generate_canslim_assessment: {e}")
        return "Could not generate CANSLIM assessment."

def generate_fundamental_conclusion(company_name: str, piotroski_data: dict, graham_data: dict, darvas_data: dict, key_stats: dict, news_headlines: list):
    """Performs a meta-analysis based on Hard Scores and Key Metrics."""
    try:
        configure_gemini_for_request()
        model = genai.GenerativeModel('gemini-2.5-flash')
        
        p_score = piotroski_data.get('score', 'N/A') if piotroski_data else 'N/A'
        g_score = graham_data.get('score', 'N/A') if graham_data else 'N/A'
        d_status = darvas_data.get('status', 'N/A') if darvas_data else 'N/A'
        pe = key_stats.get('peRatio', 'N/A')
        
        news_str = "- " + "\n- ".join(news_headlines[:3]) if news_headlines else "No recent news."

        prompt = f"""Act as a Senior Portfolio Manager. Analyze {company_name}.
        **Hard Numbers:** Piotroski: {p_score}/9, Graham Scan: {g_score}/7, Darvas Status: {d_status}, P/E: {pe}.
        **News Context:** {news_str}
        Synthesize into: GRADE: [A-F], THESIS: [Sentence], TAKEAWAYS: [3 bullets]."""
        
        response = model.generate_content(prompt)
        return response.text.strip()
    except Exception as e:
        print(f"Error in fundamental conclusion: {e}")
        return "GRADE: N/A\nTHESIS: Analysis unavailable."

def find_peer_tickers_by_industry(company_name: str, sector: str, industry: str, country: str):
    """Uses Gemini AI to find a list of top 5 competitor tickers."""
    try:
        configure_gemini_for_request()
        model = genai.GenerativeModel('gemini-2.5-flash')
        prompt = f"""Act as an expert financial data analyst. The company is {company_name}, in the "{industry}" industry within the "{sector}" sector in {country}. Identify top 5 publicly traded competitors. Return comma-separated tickers ONLY. US: AAPL, MSFT. India: RELIANCE.NS, TCS.NS."""
        response = model.generate_content(prompt)
        peers_str = response.text.strip().replace(" ", "").upper()
        return peers_str.split(',')
    except Exception as e:
        print(f"An error occurred while finding peer tickers with AI: {e}")
        return []

# --- VISION / IMAGE FUNCTIONS ---

def identify_ticker_from_image(image_bytes: bytes):
    """Identifies ticker from image."""
    try:
        configure_gemini_for_request()
        model = genai.GenerativeModel('gemini-2.5-flash')
        image_part = {"mime_type": "image/jpeg", "data": image_bytes}
        prompt = """Analyze this stock chart image. Identify the stock ticker symbol. Return ONLY the official Yahoo Finance ticker symbol (e.g., "AAPL", "RELIANCE.NS"). If not found, return "NOT_FOUND"."""
        response = model.generate_content([prompt, image_part])
        return response.text.strip().upper()
    except Exception as e:
        print(f"Error identifying ticker: {e}")
        return "NOT_FOUND"

def analyze_chart_technicals_from_image(image_bytes: bytes):
    """Uses Gemini Vision to generate a professional, actionable Trade Setup from an image."""
    try:
        configure_gemini_for_request()
        model = genai.GenerativeModel('gemini-2.5-flash')
        image_part = {"mime_type": "image/jpeg", "data": image_bytes}
        
        prompt = """
        Act as an expert Chartered Market Technician. You have been given a stock chart image.
        Perform a comprehensive technical analysis and provide a potential trade setup.

        Your analysis MUST be structured in the following format:
        
        TREND: [Identify the primary trend: Uptrend, Downtrend, or Sideways.]
        PATTERNS: [Identify key patterns (Head and Shoulders, Flags, etc.). If none, state "None".]
        LEVELS: [Identify key Support and Resistance levels.]
        VOLUME: [Analyze volume behavior.]
        INDICATORS: [Analyze any visible indicators.]
        CONCLUSION: [A powerful summary of the technical picture.]
        
        -- TRADE TICKET --
        ACTION: [BUY / SELL / WAIT]
        ENTRY_ZONE: [Specific price range]
        STOP_LOSS: [Specific price]
        TARGET_1: [Conservative target]
        TARGET_2: [Aggressive target]
        RISK_REWARD: [e.g., 1:3]
        CONFIDENCE: [High / Medium / Low]
        RATIONALE: [One sentence explaining the trade logic]
        """
        
        response = model.generate_content([prompt, image_part])
        return response.text.strip()
        
    except Exception as e:
        print(f"AI Analysis Error: {e}")
        return "TREND: Error\nACTION: WAIT\nRATIONALE: Server could not process image."

# --- NEW: TIMEFRAME ANALYSIS FUNCTION (UPGRADED) ---

# Updated function signature to accept pivots and moving_averages
def generate_timeframe_analysis(symbol: str, timeframe: str, technical_data: dict, pivots: dict, moving_averages: dict):
    """
    Generates a trade setup based on calculated technical data, Pivots, and MAs.
    """
    try:
        configure_gemini_for_request()
        model = genai.GenerativeModel('gemini-2.5-flash')

        # --- Prepare Data Strings ---
        rsi = technical_data.get('rsi', 'N/A')
        macd = technical_data.get('macd', 'N/A')
        stoch = technical_data.get('stochasticsk', 'N/A')
        adx = technical_data.get('adx', 'N/A')
        close = technical_data.get('price_action', {}).get('current_close', 'N/A')

        # Format Pivots for the AI
        classic = pivots.get('classic', {})
        pivot_str = f"PP: {classic.get('pp', 'N/A')}, S1: {classic.get('s1', 'N/A')}, R1: {classic.get('r1', 'N/A')}"
        
        # Format Moving Averages for the AI
        ma_str = f"SMA20: {moving_averages.get('20', 'N/A')}, SMA50: {moving_averages.get('50', 'N/A')}, SMA200: {moving_averages.get('200', 'N/A')}"

        prompt = f"""
        Act as an Algorithmic Trader. Analyze the following live technical data for {symbol} on the {timeframe} timeframe.
        
        **Technical Data:**
        - Current Price: {close}
        - Momentum: RSI({rsi}), Stoch({stoch}), ADX({adx}), MACD({macd})
        - Key Levels (Pivots): {pivot_str}
        - Trends (MAs): {ma_str}

        **Your Task:**
        Generate a specific trading plan. You MUST use the Key Levels and MAs to define the Entry, Stop, and Targets.
        
        **Strict Output Format:**
        TREND: [Uptrend / Downtrend / Range]
        PATTERNS: [Chart patterns]
        MOMENTUM: [Bullish / Bearish]
        LEVELS: [Key support/resistance]
        INDICATORS: [Summary]
        CONCLUSION: [Brief summary]

        -- TRADE TICKET --
        ACTION: [BUY / SELL / WAIT]
        ENTRY_ZONE: [Specific price range around {close}]
        STOP_LOSS: [Specific price below Support/MA]
        TARGET_1: [Specific price at Resistance/Pivot]
        TARGET_2: [Extended target]
        RISK_REWARD: [e.g., 1:2]
        CONFIDENCE: [High / Medium / Low]
        RATIONALE: [Why?]
        """

        response = model.generate_content(prompt)
        return response.text.strip()

    except Exception as e:
        print(f"Error in timeframe analysis: {e}")
        return "TREND: Error\nACTION: WAIT\nRATIONALE: Analysis failed."
</file>

<file path="backend/app/routers/stocks.py">
import asyncio
import math
from fastapi import APIRouter, HTTPException, Query, Body
from ..services import fmp_service, yahoo_service, news_service, gemini_service, fundamental_service, technical_service, sentiment_service
from pydantic import BaseModel
from typing import List, Dict, Any

# --- Data Models for all POST requests ---
class SwotRequest(BaseModel):
    companyName: str
    description: str

class ForecastRequest(BaseModel):
    companyName: str
    analystRatings: List[Dict[str, Any]]
    priceTarget: Dict[str, Any]
    keyStats: Dict[str, Any]
    newsHeadlines: List[str]

class FundamentalRequest(BaseModel):
    companyName: str
    keyMetrics: Dict[str, Any]

class CanslimRequest(BaseModel):
    companyName: str
    quote: Dict[str, Any]
    quarterlyEarnings: List[Dict[str, Any]]
    annualEarnings: List[Dict[str, Any]]
    institutionalHolders: int

class ConclusionRequest(BaseModel):
    companyName: str
    piotroskiData: Dict[str, Any]
    grahamData: Dict[str, Any]
    darvasData: Dict[str, Any]
    canslimAssessment: str
    philosophyAssessment: str

# --- NEW: Model for Timeframe Analysis ---
class TimeframeRequest(BaseModel):
    timeframe: str

router = APIRouter()

# --- TRADINGVIEW SYMBOL OVERRIDE MAP ---
TRADINGVIEW_OVERRIDE_MAP = {
    "TATAPOWER.NS": "NSE:TATAPOWER",
    "RELIANCE.NS": "NSE:RELIANCE",
    # Add more here as needed
}

# --- All lazy-loading endpoints ---
@router.get("/search")
async def search_stock_ticker(query: str = Query(..., min_length=2)):
    ticker = gemini_service.get_ticker_from_query(query)
    if ticker in ["NOT_FOUND", "ERROR"]:
        raise HTTPException(status_code=404, detail=f"Could not find a ticker for '{query}'")
    return {"symbol": ticker}

@router.post("/{symbol}/swot")
async def get_swot_analysis(symbol: str, request_data: SwotRequest = Body(...)):
    print(f"Received SWOT request for {symbol}...")
    news_articles = await asyncio.to_thread(news_service.get_company_news, request_data.companyName)
    news_headlines = [article.get('title', '') for article in news_articles[:10]]
    swot_analysis = await asyncio.to_thread(
        gemini_service.generate_swot_analysis,
        request_data.companyName,
        request_data.description,
        news_headlines
    )
    return {"swot_analysis": swot_analysis}

@router.post("/{symbol}/forecast-analysis")
async def get_forecast_analysis(symbol: str, request_data: ForecastRequest = Body(...)):
    print(f"Received AI Forecast Analysis request for {symbol}...")
    analysis = await asyncio.to_thread(
        gemini_service.generate_forecast_analysis,
        company_name=request_data.companyName,
        analyst_ratings=request_data.analystRatings,
        price_target=request_data.priceTarget,
        key_stats=request_data.keyStats,
        news_headlines=request_data.newsHeadlines
    )
    return {"analysis": analysis}

@router.post("/{symbol}/fundamental-analysis")
async def get_fundamental_analysis(symbol: str, request_data: FundamentalRequest = Body(...)):
    print(f"Received AI Fundamental Analysis request for {symbol}...")
    assessment = await asyncio.to_thread(
        gemini_service.generate_investment_philosophy_assessment,
        company_name=request_data.companyName,
        key_metrics=request_data.keyMetrics
    )
    return {"assessment": assessment}

@router.post("/{symbol}/canslim-analysis")
async def get_canslim_analysis(symbol: str, request_data: CanslimRequest = Body(...)):
    print(f"Received AI CANSLIM Analysis request for {symbol}...")
    assessment = await asyncio.to_thread(
        gemini_service.generate_canslim_assessment,
        company_name=request_data.companyName,
        quote=request_data.quote,
        quarterly_earnings=request_data.quarterlyEarnings,
        annual_earnings=request_data.annualEarnings,
        institutional_holders=request_data.institutionalHolders
    )
    return {"assessment": assessment}

@router.post("/{symbol}/conclusion-analysis")
async def get_conclusion_analysis(symbol: str, request_data: ConclusionRequest = Body(...)):
    print(f"Received AI Conclusion Analysis request for {symbol}...")
    conclusion = await asyncio.to_thread(
        gemini_service.generate_fundamental_conclusion,
        company_name=request_data.companyName,
        piotroski_data=request_data.piotroskiData,
        graham_data=request_data.grahamData,
        darvas_data=request_data.darvasData,
        key_stats={k: v for k, v in request_data.dict().get('keyStats', {}).items() if v is not None}, # Sanitize inputs slightly
        news_headlines=[] # We can add headlines if available, or keep it light for conclusion
    )
    return {"conclusion": conclusion}

# --- THE UPGRADED TIMEFRAME ANALYSIS ENDPOINT ---
@router.post("/{symbol}/timeframe-analysis")
async def get_timeframe_analysis(symbol: str, request_data: TimeframeRequest = Body(...)):
    """
    Fetches fresh candle data for a specific timeframe (e.g., 15m),
    calculates technicals, pivots, and MAs on the fly, and gets an AI trade setup.
    """
    print(f"Received Timeframe Analysis request for {symbol} on {request_data.timeframe} timeframe...")
    
    # 1. Fetch historical data for this specific timeframe using our smart yahoo service
    # The yahoo_service automatically adjusts the 'period' to fit the 'interval'
    hist_df = await asyncio.to_thread(yahoo_service.get_historical_data, symbol, period="1mo", interval=request_data.timeframe)
    
    if hist_df is None or hist_df.empty:
        return {"analysis": f"Could not fetch market data for {request_data.timeframe} timeframe."}

    # 2. Calculate Indicators, Pivots, and Moving Averages on this specific dataframe
    # This gives the AI the exact price levels for the chosen timeframe
    technicals = await asyncio.to_thread(yahoo_service.calculate_technical_indicators, hist_df)
    pivots = technical_service.calculate_pivot_points(hist_df)
    mas = technical_service.calculate_moving_averages(hist_df)
    
    # 3. Ask AI for the trade setup, passing ALL this rich data
    analysis = await asyncio.to_thread(
        gemini_service.generate_timeframe_analysis,
        symbol,
        request_data.timeframe,
        technicals,
        pivots, # <-- Critical: AI needs this for Support/Resistance
        mas     # <-- Critical: AI needs this for Trend
    )
    
    return {"analysis": analysis}


@router.get("/{symbol}/peers")
async def get_peers_comparison(symbol: str):
    print(f"Received AI Peers Comparison request for {symbol}...")
    
    company_info = await asyncio.to_thread(yahoo_service.get_company_info, symbol)
    sector, industry, country, company_name = company_info.get('sector'), company_info.get('industry'), company_info.get('country'), company_info.get('longName', symbol)
    
    if not all([sector, industry, country]):
        return []

    print(f"Asking AI for peers of {company_name}...")
    peer_tickers = await asyncio.to_thread(gemini_service.find_peer_tickers_by_industry, company_name, sector, industry, country)
    
    if not peer_tickers:
        return []
    
    print(f"AI found peers: {peer_tickers}")
    all_symbols_to_fetch = [symbol] + peer_tickers
    
    # Dual-Source Peers Fetching
    fmp_peers_data = await asyncio.to_thread(fmp_service.get_peers_with_metrics, all_symbols_to_fetch)
    peers_map = {item['symbol']: item for item in fmp_peers_data}
    
    tasks_to_run = []
    for peer_symbol in all_symbols_to_fetch:
        # If FMP data is missing or incomplete (no P/E), fetch from Yahoo
        if peer_symbol not in peers_map or not peers_map[peer_symbol].get('peRatioTTM'):
            tasks_to_run.append((peer_symbol, asyncio.to_thread(yahoo_service.get_key_fundamentals, peer_symbol)))
            
    if tasks_to_run:
        fallback_results = await asyncio.gather(*[task for _, task in tasks_to_run], return_exceptions=True)
        for (peer_symbol, _), result in zip(tasks_to_run, fallback_results):
            if not isinstance(result, Exception) and result:
                if peer_symbol not in peers_map: peers_map[peer_symbol] = {"symbol": peer_symbol}
                peers_map[peer_symbol].update(result)
                
    return list(peers_map.values())


# --- THE ULTIMATE DATA FETCHING ENDPOINT ---
@router.get("/{symbol}/all")
async def get_all_stock_data(symbol: str):
    """
    This definitive endpoint fetches all required data from FMP and Yahoo Finance
    concurrently, intelligently merges it, and runs all necessary calculations.
    """
    # Step 1: Define all data fetching tasks from all sources
    tasks = {
        "fmp_profile": asyncio.to_thread(fmp_service.get_company_profile, symbol),
        "fmp_quote": asyncio.to_thread(fmp_service.get_quote, symbol),
        "fmp_key_metrics": asyncio.to_thread(fmp_service.get_key_metrics, symbol, "annual", 1),
        "fmp_income_5y": asyncio.to_thread(fmp_service.get_financial_statements, symbol, "income-statement", "annual", 5),
        "fmp_balance_5y": asyncio.to_thread(fmp_service.get_financial_statements, symbol, "balance-sheet-statement", "annual", 5),
        "fmp_cash_flow_5y": asyncio.to_thread(fmp_service.get_financial_statements, symbol, "cash-flow-statement", "annual", 5),
        
        "fmp_quarterly_income": asyncio.to_thread(fmp_service.get_financial_statements, symbol, "income-statement", "quarter", 5),
        "fmp_quarterly_balance": asyncio.to_thread(fmp_service.get_financial_statements, symbol, "balance-sheet-statement", "quarter", 5),
        "fmp_quarterly_cash_flow": asyncio.to_thread(fmp_service.get_financial_statements, symbol, "cash-flow-statement", "quarter", 5),
        
        "shareholding": asyncio.to_thread(fmp_service.get_shareholding_data, symbol),
        "news": asyncio.to_thread(news_service.get_company_news, symbol),
        
        "yf_recommendations": asyncio.to_thread(yahoo_service.get_analyst_recommendations, symbol),
        "yf_price_target": asyncio.to_thread(yahoo_service.get_price_target_data, symbol),
        "yf_historical_financials": asyncio.to_thread(yahoo_service.get_historical_financials, symbol),
        "yf_key_fundamentals": asyncio.to_thread(yahoo_service.get_key_fundamentals, symbol),
        "yf_shareholding": asyncio.to_thread(yahoo_service.get_shareholding_summary, symbol),
        "yf_quarterly_financials": asyncio.to_thread(yahoo_service.get_quarterly_financials, symbol),
    }

    # Step 2: Run all tasks concurrently with UNBREAKABLE Error Handling
    try:
        results = await asyncio.gather(*tasks.values(), return_exceptions=True)
        raw_data = dict(zip(tasks.keys(), results))
    except Exception as e:
        print(f"CRITICAL ASYNCIO ERROR: {e}")
        raise HTTPException(status_code=500, detail="A critical error occurred while fetching data.")

    final_data = {}

    # Unbreakable Error Handling
    for key, value in raw_data.items():
        if isinstance(value, BaseException):
            print(f"HANDLED SEVERE ERROR for '{key}': {value}")
            raw_data[key] = {} if 'profile' in key or 'quote' in key or 'metrics' in key else []

    def safe_get_first(data, default={}):
        if isinstance(data, list) and len(data) > 0: return data[0]
        return default
    
    # --- HELPER: Validate Financial Data ---
    def is_data_valid(data_list):
        if not data_list or not isinstance(data_list, list) or len(data_list) == 0:
            return False
        first_item = data_list[0]
        if first_item.get('netIncome') is None and first_item.get('eps') is None:
            return False
        return True

    # --- Data Merging and Cleaning ---
    
    final_data['profile'] = safe_get_first(raw_data.get('fmp_profile'))
    final_data['quote'] = safe_get_first(raw_data.get('fmp_quote'))
    
    fmp_metrics = safe_get_first(raw_data.get('fmp_key_metrics'))
    yf_fundamentals = raw_data.get('yf_key_fundamentals', {})
    final_data['key_metrics'] = {**yf_fundamentals, **fmp_metrics}

    # Annual Financials
    fmp_income = raw_data.get('fmp_income_5y', [])
    yf_income = raw_data.get('yf_historical_financials', {}).get('income', [])
    income_statements = fmp_income if is_data_valid(fmp_income) else yf_income
    final_data['annual_revenue_and_profit'] = income_statements
    
    fmp_balance = raw_data.get('fmp_balance_5y', [])
    yf_balance = raw_data.get('yf_historical_financials', {}).get('balance', [])
    balance_sheets = fmp_balance if is_data_valid(fmp_balance) else yf_balance
    final_data['annual_balance_sheets'] = balance_sheets
    
    fmp_cash_flow = raw_data.get('fmp_cash_flow_5y', [])
    yf_cash_flow = raw_data.get('yf_historical_financials', {}).get('cash_flow', [])
    cash_flow_statements = fmp_cash_flow if is_data_valid(fmp_cash_flow) else yf_cash_flow
    final_data['annual_cash_flow_statements'] = cash_flow_statements
    
    # Quarterly Financials
    fmp_q_income = raw_data.get('fmp_quarterly_income', [])
    yf_q_income = raw_data.get('yf_quarterly_financials', {}).get('income', [])
    final_data['quarterly_income_statements'] = fmp_q_income if is_data_valid(fmp_q_income) else yf_q_income
    
    fmp_q_balance = raw_data.get('fmp_quarterly_balance', [])
    yf_q_balance = raw_data.get('yf_quarterly_financials', {}).get('balance', [])
    final_data['quarterly_balance_sheets'] = fmp_q_balance if is_data_valid(fmp_q_balance) else yf_q_balance
    
    fmp_q_cash = raw_data.get('fmp_quarterly_cash_flow', [])
    yf_q_cash = raw_data.get('yf_quarterly_financials', {}).get('cash_flow', [])
    final_data['quarterly_cash_flow_statements'] = fmp_q_cash if is_data_valid(fmp_q_cash) else yf_q_cash

    # Calculations
    final_data['piotroski_f_score'] = fundamental_service.calculate_piotroski_f_score(
        final_data['annual_revenue_and_profit'], 
        final_data['annual_balance_sheets'], 
        final_data['annual_cash_flow_statements']
    )
    final_data['graham_scan'] = fundamental_service.calculate_graham_scan(
        final_data['profile'], final_data['key_metrics'], final_data['annual_revenue_and_profit']
    )

    hist_df = await asyncio.to_thread(yahoo_service.get_historical_data, symbol, "300d")
    final_data['technical_indicators'] = await asyncio.to_thread(yahoo_service.calculate_technical_indicators, hist_df)
    final_data['darvas_scan'] = technical_service.calculate_darvas_box(hist_df, final_data['quote'], final_data['profile'].get('currency'))
    final_data['moving_averages'] = technical_service.calculate_moving_averages(hist_df)
    final_data['pivot_points'] = technical_service.calculate_pivot_points(hist_df)
    
    final_data['overall_sentiment'] = sentiment_service.calculate_overall_sentiment(
        piotroski_score=final_data['piotroski_f_score'].get('score'),
        pe_ratio=final_data['key_metrics'].get('peRatioTTM'),
        analyst_ratings=raw_data.get('yf_recommendations', []),
        rsi=final_data['technical_indicators'].get('rsi')
    )
    
    # Shareholding Merge
    yf_shareholding = raw_data.get('yf_shareholding', {})
    if yf_shareholding and yf_shareholding.get('promoter', 0) > 0:
        final_data['shareholding_breakdown'] = yf_shareholding
    else:
        fmp_shareholding = raw_data.get('shareholding', [])
        total_inst = sum(h.get('shares', 0) for h in fmp_shareholding)
        final_data['shareholding_breakdown'] = {"promoter": 0, "fii": total_inst * 0.6, "dii": total_inst * 0.4, "public": 0}
    
    final_data['shareholding'] = raw_data.get('shareholding', [])
    final_data['news'] = raw_data.get('news', [])
    final_data['analyst_ratings'] = raw_data.get('yf_recommendations', [])
    final_data['price_target_consensus'] = raw_data.get('yf_price_target', {})

    tv_symbol = symbol
    if symbol in TRADINGVIEW_OVERRIDE_MAP:
        tv_symbol = TRADINGVIEW_OVERRIDE_MAP[symbol]
    elif symbol.endswith(".NS"):
        tv_symbol = symbol.replace(".NS", "")
    elif symbol.endswith(".BO"):
        tv_symbol = "BSE:" + symbol.replace(".BO", "")
    final_data['profile']['tradingview_symbol'] = tv_symbol

    keyStats_metrics = final_data.get('key_metrics', {})
    keyStats_profile = final_data.get('profile', {})
    keyStats_quote = final_data.get('quote', {})
    keyStats_estimates = raw_data.get('analyst_estimates', {})
    
    # --- DATA SANITIZATION ---
    def sanitize_float(value):
        if isinstance(value, float) and (math.isnan(value) or math.isinf(value)):
            return None
        return value

    raw_stats = {
        "marketCap": keyStats_profile.get('mktCap') or keyStats_metrics.get('marketCap'),
        "dividendYield": keyStats_metrics.get('dividendYieldTTM'),
        "peRatio": keyStats_metrics.get('peRatioTTM'),
        "basicEPS": keyStats_metrics.get('epsTTM'),
        "netIncome": keyStats_metrics.get('netIncomePerShareTTM'),
        "revenue": keyStats_metrics.get('revenuePerShareTTM'),
        "sharesFloat": keyStats_quote.get('sharesOutstanding') or keyStats_metrics.get('sharesOutstanding'),
        "beta": keyStats_profile.get('beta') or keyStats_metrics.get('beta'),
        "employees": keyStats_profile.get('fullTimeEmployees') or keyStats_metrics.get('fullTimeEmployees'),
        "nextReportDate": keyStats_estimates.get('date'),
        "epsEstimate": keyStats_estimates.get('estimatedEpsAvg'),
        "revenueEstimate": keyStats_estimates.get('estimatedRevenueAvg'),
    }
    
    final_data['keyStats'] = {k: sanitize_float(v) for k, v in raw_stats.items()}
    
    # Sanitize the entire object
    def clean_nans(obj):
        if isinstance(obj, float):
            if math.isnan(obj) or math.isinf(obj): return None
            return obj
        elif isinstance(obj, dict):
            return {k: clean_nans(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [clean_nans(v) for v in obj]
        return obj

    return clean_nans(final_data)
</file>

<file path="frontend/src/pages/StockDetailPage.js">
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import styled, { keyframes } from 'styled-components';
import axios from 'axios';

// --- Imports for all our high-end components ---
import StockHeader from '../components/Header/StockHeader';
import Financials from '../components/Financials/Financials';
import Shareholding from '../components/Shareholding/Shareholding';
import Technicals from '../components/Technicals/Technicals';
import TradingViewChart from '../components/Chart/TradingViewChart';
import SwotAnalysis from '../components/SWOT/SwotAnalysis';
import NewsList from '../components/News/NewsList';
import { Tabs, TabPanel } from '../components/common/Tabs/Tabs';
import Forecasts from '../components/Forecasts/Forecasts';
import Fundamentals from '../components/Fundamentals/Fundamentals';
import OverallSentiment from '../components/Sentiment/OverallSentiment';
import PeersComparison from '../components/Peers/PeersComparison';
import { useLocation } from 'react-router-dom';
import ChartAnalysis from '../components/StockDetailPage/ChartAnalysis';

// --- Styled Components ---

const fadeIn = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;

const StockDetailPageContainer = styled.div`
  padding: 2rem 3rem;
  max-width: 1800px;
  margin: 0 auto;
  animation: ${fadeIn} 0.5s ease-in;
`;

const TabContentGrid = styled.div`
  display: grid;
  grid-template-columns: 2fr 1fr;
  gap: 2rem;

  @media (max-width: 1200px) {
    grid-template-columns: 1fr;
  }
`;

const LeftColumn = styled.div`
  display: flex;
  flex-direction: column;
  gap: 2rem;
`;

const RightColumn = styled.div`
  display: flex;
  flex-direction: column;
  gap: 2rem;
`;

const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 90vh;
  color: var(--color-primary);
  font-size: 1.5rem;
`;

const ErrorContainer = styled(LoadingContainer)`
  color: var(--color-danger);
`;

const BackButton = styled.button`
  background: none;
  border: 1px solid var(--color-border);
  color: var(--color-text-secondary);
  padding: 8px 16px;
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9rem;
  margin-bottom: 2rem;
  transition: all 0.2s ease;

  &:hover {
    background-color: var(--color-secondary);
    color: var(--color-text-primary);
  }
`;

// --- The Robust Page Component ---

const StockDetailPage = () => {
  const { symbol } = useParams();
  const navigate = useNavigate();
  const location = useLocation();
  const chartAnalysisData = location.state?.chartAnalysis;
  const chartTechnicalData = location.state?.technicalData;
  
  const [stockData, setStockData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  const [swotAnalysis, setSwotAnalysis] = useState('');
  const [isLoadingSwot, setIsLoadingSwot] = useState(true);
  const [philosophyAssessment, setPhilosophyAssessment] = useState('');
  const [canslimAssessment, setCanslimAssessment] = useState('');
  const [conclusion, setConclusion] = useState('');
  const [isLoadingPhilosophy, setIsLoadingPhilosophy] = useState(true);
  const [isLoadingCanslim, setIsLoadingCanslim] = useState(true);
  const [isLoadingConclusion, setIsLoadingConclusion] = useState(true);

  // Hook 1: Fetch Main Data
  useEffect(() => {
    const fetchAllData = async () => {
      setIsLoading(true);
      setError(null);
      setSwotAnalysis(''); setPhilosophyAssessment(''); setCanslimAssessment(''); setConclusion('');
      try {
        const response = await axios.get(`/api/stocks/${symbol}/all`);
        setStockData(response.data);
      } catch (err) {
        console.error("Failed to fetch stock data:", err);
        setError(`Could not retrieve data for ${symbol}. Please check the symbol and try again.`);
      } finally {
        setIsLoading(false);
      }
    };
    fetchAllData();
  }, [symbol]);

  // Hook 2: Fetch AI Analyses (Lazy Loading)
  useEffect(() => {
    if (!stockData) return;

    // 1. SWOT Analysis
    const fetchSwotAnalysis = () => {
      if (!stockData.profile?.description) { setIsLoadingSwot(false); return Promise.resolve(); }
      setIsLoadingSwot(true);
      const payload = { companyName: stockData.profile.companyName, description: stockData.profile.description };
      return axios.post(`/api/stocks/${symbol}/swot`, payload)
        .then(res => setSwotAnalysis(res.data.swot_analysis))
        .catch(() => setSwotAnalysis("Could not generate SWOT analysis."))
        .finally(() => setIsLoadingSwot(false));
    };

    // 2. Philosophy Assessment
    const fetchPhilosophyAssessment = () => {
      if (!stockData.profile || !stockData.key_metrics) { setIsLoadingPhilosophy(false); return Promise.resolve(); }
      setIsLoadingPhilosophy(true);
      const payload = { companyName: stockData.profile.companyName, keyMetrics: stockData.key_metrics };
      return axios.post(`/api/stocks/${symbol}/fundamental-analysis`, payload)
        .then(res => setPhilosophyAssessment(res.data.assessment))
        .catch(() => setPhilosophyAssessment("Could not generate AI assessment."))
        .finally(() => setIsLoadingPhilosophy(false));
    };
    
    // 3. CANSLIM Assessment
    const fetchCanslimAssessment = () => {
      // Robust check: Ensure all required data arrays exist before proceeding
      if (!stockData.profile || !stockData.quote || !stockData.quarterly_income_statements) { 
          setIsLoadingCanslim(false); return Promise.resolve(); 
      }
      setIsLoadingCanslim(true);
      
      try {
          const payload = {
            companyName: stockData.profile.companyName, 
            quote: stockData.quote, 
            quarterlyEarnings: stockData.quarterly_income_statements,
            annualEarnings: stockData.annual_revenue_and_profit || [], // Default to empty array if missing
            // --- THIS IS THE CRITICAL FIX ---
            // Safely access .length using optional chaining (?.) and default to 0
            institutionalHolders: stockData.shareholding ? stockData.shareholding.length : 0,
          };
          return axios.post(`/api/stocks/${symbol}/canslim-analysis`, payload)
            .then(res => setCanslimAssessment(res.data.assessment))
            .catch(() => setCanslimAssessment("Could not generate CANSLIM assessment."))
            .finally(() => setIsLoadingCanslim(false));
      } catch (e) {
          console.error("Error preparing CANSLIM payload:", e);
          setIsLoadingCanslim(false);
          return Promise.resolve();
      }
    };

    // 4. Conclusion Analysis (Runs last)
    const fetchConclusionAnalysis = (philosophyRes, canslimRes) => {
      // Safe check for dependency data
      if (!stockData.piotroski_f_score || !stockData.graham_scan || !stockData.keyStats) { 
          setIsLoadingConclusion(false); return; 
      }
      setIsLoadingConclusion(true);
      const payload = {
        companyName: stockData.profile.companyName, 
        piotroskiData: stockData.piotroski_f_score,
        grahamData: stockData.graham_scan, 
        darvasData: stockData.darvas_scan,
        canslimAssessment: canslimRes, 
        philosophyAssessment: philosophyRes,
        keyStats: stockData.keyStats,
        newsHeadlines: stockData.news ? stockData.news.slice(0, 5).map(n => n.title) : []
      };
      axios.post(`/api/stocks/${symbol}/conclusion-analysis`, payload)
        .then(res => setConclusion(res.data.conclusion))
        .catch(() => setConclusion("GRADE: N/A\nTHESIS: Could not generate AI conclusion."))
        .finally(() => setIsLoadingConclusion(false));
    };

    // Execute the chain
    Promise.all([
      fetchSwotAnalysis(),
      fetchPhilosophyAssessment(),
      fetchCanslimAssessment()
    ]).then(() => {
      // Use functional state updates to ensure we have the very latest values
      setPhilosophyAssessment(currentPhilosophy => {
        setCanslimAssessment(currentCanslim => {
          setTimeout(() => fetchConclusionAnalysis(currentPhilosophy, currentCanslim), 200);
          return currentCanslim;
        });
        return currentPhilosophy;
      });
    });

  }, [stockData, symbol]);

  // --- Render Logic ---

  if (isLoading) {
    return (
      <LoadingContainer>
        <p>Loading Financial Universe for {symbol}...</p>
      </LoadingContainer>
    );
  }

  if (error) {
    return (
      <ErrorContainer>
        <h2>An Error Occurred</h2>
        <p>{error}</p>
        <BackButton style={{ marginTop: '2rem' }} onClick={() => navigate('/')}>
          Go Back to Search
        </BackButton>
      </ErrorContainer>
    );
  }

  if (!stockData) {
    return null;
  }

  const tradingViewSymbol = stockData.profile?.tradingview_symbol || symbol;

  return (
    <StockDetailPageContainer>
      <BackButton onClick={() => navigate('/')}>&larr; Back to Search</BackButton>
      
      <StockHeader profile={stockData.profile} quote={stockData.quote} />
      
      <Tabs>
        {chartAnalysisData && (
          <TabPanel label="Chart AI">
            <ChartAnalysis analysisData={chartAnalysisData} technicalData={chartTechnicalData} />
          </TabPanel>
        )}
        <TabPanel label="Overview">
          <TabContentGrid>
            <LeftColumn>
              <TradingViewChart symbol={tradingViewSymbol} />
              <SwotAnalysis
                analysisText={swotAnalysis}
                isLoading={isLoadingSwot}
              />
            </LeftColumn>
            <RightColumn>
              <OverallSentiment sentimentData={stockData.overall_sentiment} />
              <NewsList newsArticles={stockData.news} />
            </RightColumn>
          </TabContentGrid>
        </TabPanel>
        
        <TabPanel label="Fundamentals">
            <Fundamentals
                symbol={symbol}
                profile={stockData.profile}
                quote={stockData.quote}
                keyMetrics={stockData.key_metrics}
                piotroskiData={stockData.piotroski_f_score}
                darvasScanData={stockData.darvas_scan}
                grahamScanData={stockData.graham_scan}
                quarterlyEarnings={stockData.quarterly_income_statements}
                annualEarnings={stockData.annual_revenue_and_profit}
                shareholding={stockData.shareholding}
                delay={300}
                philosophyAssessment={philosophyAssessment}
                canslimAssessment={canslimAssessment}
                isLoadingPhilosophy={isLoadingPhilosophy}
                isLoadingCanslim={isLoadingCanslim}
                isLoadingConclusion={isLoadingConclusion}
                conclusion={conclusion}
            />
        </TabPanel>

        <TabPanel label="Financials">
          <Financials 
            profile={stockData.profile}
            keyStats={stockData.keyStats}
            financialData={stockData.annual_revenue_and_profit} 
            balanceSheetData={stockData.annual_balance_sheets}
            annualCashFlow={stockData.annual_cash_flow_statements}
            quarterlyIncome={stockData.quarterly_income_statements}
            quarterlyBalance={stockData.quarterly_balance_sheets}
            quarterlyCashFlow={stockData.quarterly_cash_flow_statements}
          />
        </TabPanel>
        
        <TabPanel label="Forecasts">
            <Forecasts 
                symbol={symbol}
                quote={stockData.quote}
                analystRatings={stockData.analyst_ratings}
                priceTarget={stockData.price_target_consensus}
                keyStats={stockData.keyStats}
                news={stockData.news}
                delay={200}
                currency={stockData.profile?.currency}
            />
        </TabPanel>

        <TabPanel label="Peers">
            <PeersComparison symbol={symbol} />
        </TabPanel>
        
        <TabPanel label="Shareholding">
            <Shareholding 
                shareholdingData={stockData.shareholding}
                historicalStatements={stockData.annual_revenue_and_profit}
                shareholdingBreakdown={stockData.shareholding_breakdown}
            />
        </TabPanel>
        
        <TabPanel label="Technicals">
            <Technicals 
              analystRatings={stockData.analyst_ratings} 
              technicalIndicators={stockData.technical_indicators}
              movingAverages={stockData.moving_averages}
              pivotPoints={stockData.pivot_points}
            />
        </TabPanel>
      </Tabs>
    </StockDetailPageContainer>
  );
};

export default StockDetailPage;
</file>

<file path="backend/app/main.py">
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
# The following imports are commented out because they are only needed for production.
# from fastapi.staticfiles import StaticFiles
# from fastapi.responses import FileResponse
# import os

# We must import ALL of our routers to make their endpoints available.
from .routers import stocks, indices, charts

# Create the main FastAPI application instance.
app = FastAPI(
    title="Stellar Stock Screener API (Development Mode)",
    description="A high-performance API serving financial data for the stock screener frontend.",
    version="1.0.0"
)

# --- CORS MIDDLEWARE (ESSENTIAL FOR LOCAL DEVELOPMENT) ---
# This is the "permission slip" that allows your React app (running on http://localhost:3000)
# to make API calls to this Python backend (running on http://localhost:8000).
# Without this, the browser blocks the connection for security reasons.
origins = [
    "http://localhost:3000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True, # Allows cookies to be included in requests
    allow_methods=["*"],     # Allows all HTTP methods (GET, POST, etc.)
    allow_headers=["*"],     # Allows all request headers
)

# --- ROUTER INCLUSION ---
# We include all our API routers here so the server knows what code to run.
app.include_router(stocks.router, prefix="/api/stocks", tags=["stocks"])
app.include_router(indices.router, prefix="/api/indices", tags=["indices"])
app.include_router(charts.router, prefix="/api/charts", tags=["charts"])


# --- PRODUCTION-ONLY CODE (DISABLED) ---
# The code block below is responsible for serving the built React application on the live server.
# It is commented out (#) for local development because the 'frontend/build' directory
# usually doesn't exist or isn't updated during dev. The `npm start` server handles this.

# app.mount("/static", StaticFiles(directory="frontend/build/static"), name="static_assets")

# @app.get("/{full_path:path}")
# async def serve_react_app(full_path: str):
#     # We must construct the path to the index.html file within our Docker container.
#     build_dir = "frontend/build"
#     index_path = os.path.join(build_dir, "index.html")

#     # Check if the file exists to prevent server errors.
#     if not os.path.exists(index_path):
#         return {"error": "index.html not found in build directory"}, 500

#     return FileResponse(index_path)
</file>

</files>
